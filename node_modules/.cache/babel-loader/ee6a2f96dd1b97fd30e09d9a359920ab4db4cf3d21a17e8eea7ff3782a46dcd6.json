{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeBytecode = exports.compareBytecode = exports.extractMatchingContractInformation = exports.lookupMatchingBytecode = exports.Bytecode = void 0;\nconst contract_names_1 = require(\"hardhat/utils/contract-names\");\nconst metadata_1 = require(\"./metadata\");\n// If the compiler output bytecode is OVM bytecode, we need to make a fix to account for a bug in some versions of\n// the OVM compiler. The artifact’s deployedBytecode is incorrect, but because its bytecode (initcode) is correct, when we\n// actually deploy contracts, the code that ends up getting stored on chain is also correct. During verification,\n// Etherscan will compile the source code, pull out the artifact’s deployedBytecode, and then perform the\n// below find and replace, then check that resulting output against the code retrieved on chain from eth_getCode.\n// We define the strings for that find and replace here, and use them later so we can know if the bytecode matches\n// before it gets to Etherscan. Source: https://github.com/ethereum-optimism/optimism/blob/8d67991aba584c1703692ea46273ea8a1ef45f56/packages/contracts/src/contract-dumps.ts#L195-L204\nconst ovmFindOpcodes = \"336000905af158601d01573d60011458600c01573d6000803e3d621234565260ea61109c52\";\nconst ovmReplaceOpcodes = \"336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b\";\nclass Bytecode {\n  constructor(bytecode) {\n    this._bytecode = bytecode;\n    const {\n      solcVersion,\n      metadataSectionSizeInBytes\n    } = (0, metadata_1.inferSolcVersion)(Buffer.from(bytecode, \"hex\"));\n    this._version = solcVersion;\n    this._executableSection = {\n      start: 0,\n      length: bytecode.length - metadataSectionSizeInBytes * 2\n    };\n    this._metadataSection = {\n      start: this._executableSection.length,\n      length: metadataSectionSizeInBytes * 2\n    };\n    // Check if this is OVM bytecode by looking for the concatenation of the two opcodes defined here:\n    // https://github.com/ethereum-optimism/optimism/blob/33cb9025f5e463525d6abe67c8457f81a87c5a24/packages/contracts/contracts/optimistic-ethereum/OVM/execution/OVM_SafetyChecker.sol#L143\n    //   - This check would only fail if the EVM solidity compiler didn't use any of the following opcodes: https://github.com/ethereum-optimism/optimism/blob/c42fc0df2790a5319027393cb8fa34e4f7bb520f/packages/contracts/contracts/optimistic-ethereum/iOVM/execution/iOVM_ExecutionManager.sol#L94-L175\n    //     This is the list of opcodes that calls the OVM execution manager. But the current solidity\n    //     compiler seems to add REVERT in all cases, meaning it currently won't happen and this check\n    //     will always be correct.\n    //   - It is possible, though very unlikely, that this string appears in the bytecode of an EVM\n    //     contract. As a result result, this _isOvm flag should only be used after trying to infer\n    //     the solc version\n    //   - We need this check because OVM bytecode has no metadata, so when verifying\n    //     OVM bytecode the check in `inferSolcVersion` will always return `METADATA_ABSENT_VERSION_RANGE`.\n    this._isOvm = bytecode.includes(ovmReplaceOpcodes);\n  }\n  getInferredSolcVersion() {\n    return this._version;\n  }\n  isOvmInferred() {\n    return this._isOvm;\n  }\n  getExecutableSection() {\n    const {\n      start,\n      length\n    } = this._executableSection;\n    return this._bytecode.slice(start, length);\n  }\n  hasMetadata() {\n    return this._metadataSection.length > 0;\n  }\n}\nexports.Bytecode = Bytecode;\nasync function lookupMatchingBytecode(artifacts, matchingCompilerVersions, deployedBytecode) {\n  const contractMatches = [];\n  const fqNames = await artifacts.getAllFullyQualifiedNames();\n  for (const fqName of fqNames) {\n    const buildInfo = await artifacts.getBuildInfo(fqName);\n    if (buildInfo === undefined) {\n      continue;\n    }\n    if (!matchingCompilerVersions.includes(buildInfo.solcVersion) &&\n    // if OVM, we will not have matching compiler versions because we can't infer a specific OVM solc version from the bytecode\n    !deployedBytecode.isOvmInferred()) {\n      continue;\n    }\n    const {\n      sourceName,\n      contractName\n    } = (0, contract_names_1.parseFullyQualifiedName)(fqName);\n    const contractInformation = await extractMatchingContractInformation(sourceName, contractName, buildInfo, deployedBytecode);\n    if (contractInformation !== null) {\n      contractMatches.push(contractInformation);\n    }\n  }\n  return contractMatches;\n}\nexports.lookupMatchingBytecode = lookupMatchingBytecode;\nasync function extractMatchingContractInformation(sourceName, contractName, buildInfo, deployedBytecode) {\n  const contract = buildInfo.output.contracts[sourceName][contractName];\n  // Normalize deployed bytecode according to this contract.\n  const {\n    deployedBytecode: runtimeBytecodeSymbols\n  } = contract.evm;\n  // If this is OVM bytecode, do the required find and replace (see above comments for more info)\n  if (deployedBytecode.isOvmInferred()) {\n    runtimeBytecodeSymbols.object = runtimeBytecodeSymbols.object.split(ovmFindOpcodes).join(ovmReplaceOpcodes);\n  }\n  const analyzedBytecode = await compareBytecode(deployedBytecode, runtimeBytecodeSymbols);\n  if (analyzedBytecode !== null) {\n    return {\n      ...analyzedBytecode,\n      compilerInput: buildInfo.input,\n      compilerOutput: buildInfo.output,\n      solcVersion: buildInfo.solcVersion,\n      sourceName,\n      contractName,\n      contract\n    };\n  }\n  return null;\n}\nexports.extractMatchingContractInformation = extractMatchingContractInformation;\nasync function compareBytecode(deployedBytecode, runtimeBytecodeSymbols) {\n  // We will ignore metadata information when comparing. Etherscan seems to do the same.\n  const deployedExecutableSection = deployedBytecode.getExecutableSection();\n  const runtimeBytecodeExecutableSectionLength = (0, metadata_1.measureExecutableSectionLength)(runtimeBytecodeSymbols.object);\n  if (deployedExecutableSection.length !== runtimeBytecodeExecutableSectionLength &&\n  // OVM bytecode has no metadata so we ignore this comparison if operating on OVM bytecode\n  !deployedBytecode.isOvmInferred()) {\n    return null;\n  }\n  // Normalize deployed bytecode according to this contract.\n  const {\n    immutableValues,\n    libraryLinks,\n    normalizedBytecode\n  } = await normalizeBytecode(deployedExecutableSection, runtimeBytecodeSymbols);\n  // Library hash placeholders are embedded into the bytes where the library addresses are linked.\n  // We need to zero them out to compare them.\n  const {\n    normalizedBytecode: referenceBytecode\n  } = await normalizeBytecode(runtimeBytecodeSymbols.object, runtimeBytecodeSymbols);\n  if (normalizedBytecode.slice(0, deployedExecutableSection.length) === referenceBytecode.slice(0, deployedExecutableSection.length)) {\n    // The bytecode matches\n    return {\n      immutableValues,\n      libraryLinks,\n      normalizedBytecode\n    };\n  }\n  return null;\n}\nexports.compareBytecode = compareBytecode;\nasync function normalizeBytecode(bytecode, symbols) {\n  const nestedSliceReferences = [];\n  const libraryLinks = {};\n  for (const [sourceName, libraries] of Object.entries(symbols.linkReferences)) {\n    for (const [libraryName, linkReferences] of Object.entries(libraries)) {\n      // Is this even a possibility?\n      if (linkReferences.length === 0) {\n        continue;\n      }\n      const {\n        start,\n        length\n      } = linkReferences[0];\n      if (libraryLinks[sourceName] === undefined) {\n        libraryLinks[sourceName] = {};\n      }\n      // We have the bytecode encoded as a hex string\n      libraryLinks[sourceName][libraryName] = `0x${bytecode.slice(start * 2, (start + length) * 2)}`;\n      nestedSliceReferences.push(linkReferences);\n    }\n  }\n  const immutableValues = {};\n  if (symbols.immutableReferences !== undefined && symbols.immutableReferences !== null) {\n    for (const [key, immutableReferences] of Object.entries(symbols.immutableReferences)) {\n      // Is this even a possibility?\n      if (immutableReferences.length === 0) {\n        continue;\n      }\n      const {\n        start,\n        length\n      } = immutableReferences[0];\n      immutableValues[key] = bytecode.slice(start * 2, (start + length) * 2);\n      nestedSliceReferences.push(immutableReferences);\n    }\n  }\n  // To normalize a library object we need to take into account its call protection mechanism.\n  // See https://solidity.readthedocs.io/en/latest/contracts.html#call-protection-for-libraries\n  const addressSize = 20;\n  const push20OpcodeHex = \"73\";\n  const pushPlaceholder = push20OpcodeHex + \"0\".repeat(addressSize * 2);\n  if (symbols.object.startsWith(pushPlaceholder) && bytecode.startsWith(push20OpcodeHex)) {\n    nestedSliceReferences.push([{\n      start: 1,\n      length: addressSize\n    }]);\n  }\n  const sliceReferences = flattenSlices(nestedSliceReferences);\n  const normalizedBytecode = zeroOutSlices(bytecode, sliceReferences);\n  return {\n    libraryLinks,\n    immutableValues,\n    normalizedBytecode\n  };\n}\nexports.normalizeBytecode = normalizeBytecode;\nfunction flattenSlices(slices) {\n  return [].concat(...slices);\n}\nfunction zeroOutSlices(code, slices) {\n  for (const {\n    start,\n    length\n  } of slices) {\n    code = [code.slice(0, start * 2), \"0\".repeat(length * 2), code.slice((start + length) * 2)].join(\"\");\n  }\n  return code;\n}","map":{"version":3,"names":["contract_names_1","require","metadata_1","ovmFindOpcodes","ovmReplaceOpcodes","Bytecode","constructor","bytecode","_bytecode","solcVersion","metadataSectionSizeInBytes","inferSolcVersion","Buffer","from","_version","_executableSection","start","length","_metadataSection","_isOvm","includes","getInferredSolcVersion","isOvmInferred","getExecutableSection","slice","hasMetadata","exports","lookupMatchingBytecode","artifacts","matchingCompilerVersions","deployedBytecode","contractMatches","fqNames","getAllFullyQualifiedNames","fqName","buildInfo","getBuildInfo","undefined","sourceName","contractName","parseFullyQualifiedName","contractInformation","extractMatchingContractInformation","push","contract","output","contracts","runtimeBytecodeSymbols","evm","object","split","join","analyzedBytecode","compareBytecode","compilerInput","input","compilerOutput","deployedExecutableSection","runtimeBytecodeExecutableSectionLength","measureExecutableSectionLength","immutableValues","libraryLinks","normalizedBytecode","normalizeBytecode","referenceBytecode","symbols","nestedSliceReferences","libraries","Object","entries","linkReferences","libraryName","immutableReferences","key","addressSize","push20OpcodeHex","pushPlaceholder","repeat","startsWith","sliceReferences","flattenSlices","zeroOutSlices","slices","concat","code"],"sources":["/workspace/quanion/node_modules/@nomiclabs/hardhat-etherscan/src/solc/bytecode.ts"],"sourcesContent":["import {\n  Artifacts,\n  BuildInfo,\n  CompilerInput,\n  CompilerOutput,\n  CompilerOutputBytecode,\n} from \"hardhat/types\";\nimport { parseFullyQualifiedName } from \"hardhat/utils/contract-names\";\n\nimport { inferSolcVersion, measureExecutableSectionLength } from \"./metadata\";\n\ninterface BytecodeExtractedData {\n  immutableValues: ImmutableValues;\n  libraryLinks: ResolvedLinks;\n  normalizedBytecode: string;\n}\n\nexport interface ResolvedLinks {\n  [sourceName: string]: {\n    [libraryName: string]: string;\n  };\n}\n\ninterface ImmutableValues {\n  [key: string]: string;\n}\n\ntype SourceName = string;\ntype ContractName = string;\n\n// TODO: Rework this type?\n// This is actually extended by the TASK_VERIFY_GET_CONTRACT_INFORMATION subtask\n// to add the libraries that are not detectable to the context.\nexport interface ContractInformation extends BytecodeExtractedData {\n  compilerInput: CompilerInput;\n  compilerOutput: CompilerOutput;\n  solcVersion: string;\n  sourceName: SourceName;\n  contractName: ContractName;\n  contract: CompilerOutput[\"contracts\"][SourceName][ContractName];\n}\n\ninterface BytecodeSlice {\n  start: number;\n  length: number;\n}\n\ntype NestedSliceReferences = BytecodeSlice[][];\n\n// If the compiler output bytecode is OVM bytecode, we need to make a fix to account for a bug in some versions of\n// the OVM compiler. The artifact’s deployedBytecode is incorrect, but because its bytecode (initcode) is correct, when we\n// actually deploy contracts, the code that ends up getting stored on chain is also correct. During verification,\n// Etherscan will compile the source code, pull out the artifact’s deployedBytecode, and then perform the\n// below find and replace, then check that resulting output against the code retrieved on chain from eth_getCode.\n// We define the strings for that find and replace here, and use them later so we can know if the bytecode matches\n// before it gets to Etherscan. Source: https://github.com/ethereum-optimism/optimism/blob/8d67991aba584c1703692ea46273ea8a1ef45f56/packages/contracts/src/contract-dumps.ts#L195-L204\nconst ovmFindOpcodes =\n  \"336000905af158601d01573d60011458600c01573d6000803e3d621234565260ea61109c52\";\nconst ovmReplaceOpcodes =\n  \"336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760016000f35b\";\n\nexport class Bytecode {\n  private _bytecode: string;\n  private _version: string;\n  private _isOvm: boolean;\n\n  private _executableSection: BytecodeSlice;\n  private _metadataSection: BytecodeSlice;\n\n  constructor(bytecode: string) {\n    this._bytecode = bytecode;\n    const { solcVersion, metadataSectionSizeInBytes } = inferSolcVersion(\n      Buffer.from(bytecode, \"hex\")\n    );\n    this._version = solcVersion;\n    this._executableSection = {\n      start: 0,\n      length: bytecode.length - metadataSectionSizeInBytes * 2,\n    };\n    this._metadataSection = {\n      start: this._executableSection.length,\n      length: metadataSectionSizeInBytes * 2,\n    };\n\n    // Check if this is OVM bytecode by looking for the concatenation of the two opcodes defined here:\n    // https://github.com/ethereum-optimism/optimism/blob/33cb9025f5e463525d6abe67c8457f81a87c5a24/packages/contracts/contracts/optimistic-ethereum/OVM/execution/OVM_SafetyChecker.sol#L143\n    //   - This check would only fail if the EVM solidity compiler didn't use any of the following opcodes: https://github.com/ethereum-optimism/optimism/blob/c42fc0df2790a5319027393cb8fa34e4f7bb520f/packages/contracts/contracts/optimistic-ethereum/iOVM/execution/iOVM_ExecutionManager.sol#L94-L175\n    //     This is the list of opcodes that calls the OVM execution manager. But the current solidity\n    //     compiler seems to add REVERT in all cases, meaning it currently won't happen and this check\n    //     will always be correct.\n    //   - It is possible, though very unlikely, that this string appears in the bytecode of an EVM\n    //     contract. As a result result, this _isOvm flag should only be used after trying to infer\n    //     the solc version\n    //   - We need this check because OVM bytecode has no metadata, so when verifying\n    //     OVM bytecode the check in `inferSolcVersion` will always return `METADATA_ABSENT_VERSION_RANGE`.\n    this._isOvm = bytecode.includes(ovmReplaceOpcodes);\n  }\n\n  public getInferredSolcVersion(): string {\n    return this._version;\n  }\n\n  public isOvmInferred(): boolean {\n    return this._isOvm;\n  }\n\n  public getExecutableSection(): string {\n    const { start, length } = this._executableSection;\n    return this._bytecode.slice(start, length);\n  }\n\n  public hasMetadata(): boolean {\n    return this._metadataSection.length > 0;\n  }\n}\n\nexport async function lookupMatchingBytecode(\n  artifacts: Artifacts,\n  matchingCompilerVersions: string[],\n  deployedBytecode: Bytecode\n): Promise<ContractInformation[]> {\n  const contractMatches = [];\n  const fqNames = await artifacts.getAllFullyQualifiedNames();\n\n  for (const fqName of fqNames) {\n    const buildInfo = await artifacts.getBuildInfo(fqName);\n\n    if (buildInfo === undefined) {\n      continue;\n    }\n\n    if (\n      !matchingCompilerVersions.includes(buildInfo.solcVersion) &&\n      // if OVM, we will not have matching compiler versions because we can't infer a specific OVM solc version from the bytecode\n      !deployedBytecode.isOvmInferred()\n    ) {\n      continue;\n    }\n\n    const { sourceName, contractName } = parseFullyQualifiedName(fqName);\n\n    const contractInformation = await extractMatchingContractInformation(\n      sourceName,\n      contractName,\n      buildInfo,\n      deployedBytecode\n    );\n    if (contractInformation !== null) {\n      contractMatches.push(contractInformation);\n    }\n  }\n\n  return contractMatches;\n}\n\nexport async function extractMatchingContractInformation(\n  sourceName: SourceName,\n  contractName: ContractName,\n  buildInfo: BuildInfo,\n  deployedBytecode: Bytecode\n): Promise<ContractInformation | null> {\n  const contract = buildInfo.output.contracts[sourceName][contractName];\n  // Normalize deployed bytecode according to this contract.\n  const { deployedBytecode: runtimeBytecodeSymbols } = contract.evm;\n\n  // If this is OVM bytecode, do the required find and replace (see above comments for more info)\n  if (deployedBytecode.isOvmInferred()) {\n    runtimeBytecodeSymbols.object = runtimeBytecodeSymbols.object\n      .split(ovmFindOpcodes)\n      .join(ovmReplaceOpcodes);\n  }\n\n  const analyzedBytecode = await compareBytecode(\n    deployedBytecode,\n    runtimeBytecodeSymbols\n  );\n\n  if (analyzedBytecode !== null) {\n    return {\n      ...analyzedBytecode,\n      compilerInput: buildInfo.input,\n      compilerOutput: buildInfo.output,\n      solcVersion: buildInfo.solcVersion,\n      sourceName,\n      contractName,\n      contract,\n    };\n  }\n\n  return null;\n}\n\nexport async function compareBytecode(\n  deployedBytecode: Bytecode,\n  runtimeBytecodeSymbols: CompilerOutputBytecode\n): Promise<BytecodeExtractedData | null> {\n  // We will ignore metadata information when comparing. Etherscan seems to do the same.\n  const deployedExecutableSection = deployedBytecode.getExecutableSection();\n  const runtimeBytecodeExecutableSectionLength = measureExecutableSectionLength(\n    runtimeBytecodeSymbols.object\n  );\n\n  if (\n    deployedExecutableSection.length !==\n      runtimeBytecodeExecutableSectionLength &&\n    // OVM bytecode has no metadata so we ignore this comparison if operating on OVM bytecode\n    !deployedBytecode.isOvmInferred()\n  ) {\n    return null;\n  }\n\n  // Normalize deployed bytecode according to this contract.\n  const { immutableValues, libraryLinks, normalizedBytecode } =\n    await normalizeBytecode(deployedExecutableSection, runtimeBytecodeSymbols);\n\n  // Library hash placeholders are embedded into the bytes where the library addresses are linked.\n  // We need to zero them out to compare them.\n  const { normalizedBytecode: referenceBytecode } = await normalizeBytecode(\n    runtimeBytecodeSymbols.object,\n    runtimeBytecodeSymbols\n  );\n\n  if (\n    normalizedBytecode.slice(0, deployedExecutableSection.length) ===\n    referenceBytecode.slice(0, deployedExecutableSection.length)\n  ) {\n    // The bytecode matches\n    return {\n      immutableValues,\n      libraryLinks,\n      normalizedBytecode,\n    };\n  }\n\n  return null;\n}\n\nexport async function normalizeBytecode(\n  bytecode: string,\n  symbols: CompilerOutputBytecode\n): Promise<BytecodeExtractedData> {\n  const nestedSliceReferences: NestedSliceReferences = [];\n  const libraryLinks: ResolvedLinks = {};\n  for (const [sourceName, libraries] of Object.entries(\n    symbols.linkReferences\n  )) {\n    for (const [libraryName, linkReferences] of Object.entries(libraries)) {\n      // Is this even a possibility?\n      if (linkReferences.length === 0) {\n        continue;\n      }\n\n      const { start, length } = linkReferences[0];\n      if (libraryLinks[sourceName] === undefined) {\n        libraryLinks[sourceName] = {};\n      }\n      // We have the bytecode encoded as a hex string\n      libraryLinks[sourceName][libraryName] = `0x${bytecode.slice(\n        start * 2,\n        (start + length) * 2\n      )}`;\n      nestedSliceReferences.push(linkReferences);\n    }\n  }\n\n  const immutableValues: ImmutableValues = {};\n  if (\n    symbols.immutableReferences !== undefined &&\n    symbols.immutableReferences !== null\n  ) {\n    for (const [key, immutableReferences] of Object.entries(\n      symbols.immutableReferences\n    )) {\n      // Is this even a possibility?\n      if (immutableReferences.length === 0) {\n        continue;\n      }\n\n      const { start, length } = immutableReferences[0];\n      immutableValues[key] = bytecode.slice(start * 2, (start + length) * 2);\n      nestedSliceReferences.push(immutableReferences);\n    }\n  }\n\n  // To normalize a library object we need to take into account its call protection mechanism.\n  // See https://solidity.readthedocs.io/en/latest/contracts.html#call-protection-for-libraries\n  const addressSize = 20;\n  const push20OpcodeHex = \"73\";\n  const pushPlaceholder = push20OpcodeHex + \"0\".repeat(addressSize * 2);\n  if (\n    symbols.object.startsWith(pushPlaceholder) &&\n    bytecode.startsWith(push20OpcodeHex)\n  ) {\n    nestedSliceReferences.push([{ start: 1, length: addressSize }]);\n  }\n\n  const sliceReferences = flattenSlices(nestedSliceReferences);\n  const normalizedBytecode = zeroOutSlices(bytecode, sliceReferences);\n\n  return { libraryLinks, immutableValues, normalizedBytecode };\n}\n\nfunction flattenSlices(slices: NestedSliceReferences) {\n  return ([] as BytecodeSlice[]).concat(...slices);\n}\n\nfunction zeroOutSlices(\n  code: string,\n  slices: Array<{ start: number; length: number }>\n): string {\n  for (const { start, length } of slices) {\n    code = [\n      code.slice(0, start * 2),\n      \"0\".repeat(length * 2),\n      code.slice((start + length) * 2),\n    ].join(\"\");\n  }\n\n  return code;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}