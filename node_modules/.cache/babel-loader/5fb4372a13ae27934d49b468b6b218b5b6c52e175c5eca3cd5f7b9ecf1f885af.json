{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.retrieveContractBytecode = exports.getEtherscanEndpoints = void 0;\nconst plugins_1 = require(\"hardhat/plugins\");\nconst constants_1 = require(\"../constants\");\nconst errors_1 = require(\"../errors\");\nasync function getEtherscanEndpoints(provider, networkName, chainConfig, customChains) {\n  const chainIdsToNames = new Map(Object.entries(chainConfig).map(([chainName, config]) => [config.chainId, chainName]));\n  const chainID = parseInt(await provider.send(\"eth_chainId\"), 16);\n  const networkInCustomChains = [...customChains].reverse() // the last entry wins\n  .find(customChain => customChain.chainId === chainID);\n  // if there is a custom chain with the given chain id, that one is preferred\n  // over the built-in ones\n  if (networkInCustomChains !== undefined) {\n    return networkInCustomChains;\n  }\n  const network = networkInCustomChains ?? chainIdsToNames.get(chainID);\n  if (network === undefined) {\n    (0, errors_1.throwUnsupportedNetwork)(networkName, chainID);\n  }\n  const chainConfigEntry = chainConfig[network];\n  return {\n    network,\n    urls: chainConfigEntry.urls\n  };\n}\nexports.getEtherscanEndpoints = getEtherscanEndpoints;\nasync function retrieveContractBytecode(address, provider, networkName) {\n  const bytecodeString = await provider.send(\"eth_getCode\", [address, \"latest\"]);\n  const deployedBytecode = bytecodeString.startsWith(\"0x\") ? bytecodeString.slice(2) : bytecodeString;\n  if (deployedBytecode.length === 0) {\n    throw new plugins_1.NomicLabsHardhatPluginError(constants_1.pluginName, `The address ${address} has no bytecode. Is the contract deployed to this network?\nThe selected network is ${networkName}.`);\n  }\n  return deployedBytecode;\n}\nexports.retrieveContractBytecode = retrieveContractBytecode;","map":{"version":3,"names":["plugins_1","require","constants_1","errors_1","getEtherscanEndpoints","provider","networkName","chainConfig","customChains","chainIdsToNames","Map","Object","entries","map","chainName","config","chainId","chainID","parseInt","send","networkInCustomChains","reverse","find","customChain","undefined","network","get","throwUnsupportedNetwork","chainConfigEntry","urls","exports","retrieveContractBytecode","address","bytecodeString","deployedBytecode","startsWith","slice","length","NomicLabsHardhatPluginError","pluginName"],"sources":["/workspace/quanion/node_modules/@nomiclabs/hardhat-etherscan/src/network/prober.ts"],"sourcesContent":["import { NomicLabsHardhatPluginError } from \"hardhat/plugins\";\nimport { EthereumProvider } from \"hardhat/types\";\n\nimport { pluginName } from \"../constants\";\nimport { throwUnsupportedNetwork } from \"../errors\";\nimport { ChainConfig, CustomChain, EtherscanNetworkEntry } from \"../types\";\n\nexport async function getEtherscanEndpoints(\n  provider: EthereumProvider,\n  networkName: string,\n  chainConfig: ChainConfig,\n  customChains: CustomChain[]\n): Promise<EtherscanNetworkEntry> {\n  const chainIdsToNames = new Map(\n    Object.entries(chainConfig).map(([chainName, config]) => [\n      config.chainId,\n      chainName,\n    ])\n  );\n\n  const chainID = parseInt(await provider.send(\"eth_chainId\"), 16);\n\n  const networkInCustomChains = [...customChains]\n    .reverse() // the last entry wins\n    .find((customChain) => customChain.chainId === chainID);\n\n  // if there is a custom chain with the given chain id, that one is preferred\n  // over the built-in ones\n  if (networkInCustomChains !== undefined) {\n    return networkInCustomChains;\n  }\n\n  const network = networkInCustomChains ?? chainIdsToNames.get(chainID);\n\n  if (network === undefined) {\n    throwUnsupportedNetwork(networkName, chainID);\n  }\n\n  const chainConfigEntry = chainConfig[network];\n\n  return { network, urls: chainConfigEntry.urls };\n}\n\nexport async function retrieveContractBytecode(\n  address: string,\n  provider: EthereumProvider,\n  networkName: string\n): Promise<string> {\n  const bytecodeString = (await provider.send(\"eth_getCode\", [\n    address,\n    \"latest\",\n  ])) as string;\n  const deployedBytecode = bytecodeString.startsWith(\"0x\")\n    ? bytecodeString.slice(2)\n    : bytecodeString;\n  if (deployedBytecode.length === 0) {\n    throw new NomicLabsHardhatPluginError(\n      pluginName,\n      `The address ${address} has no bytecode. Is the contract deployed to this network?\nThe selected network is ${networkName}.`\n    );\n  }\n  return deployedBytecode;\n}\n"],"mappings":";;;;;;AAAA,MAAAA,SAAA,GAAAC,OAAA;AAGA,MAAAC,WAAA,GAAAD,OAAA;AACA,MAAAE,QAAA,GAAAF,OAAA;AAGO,eAAeG,qBAAqBA,CACzCC,QAA0B,EAC1BC,WAAmB,EACnBC,WAAwB,EACxBC,YAA2B;EAE3B,MAAMC,eAAe,GAAG,IAAIC,GAAG,CAC7BC,MAAM,CAACC,OAAO,CAACL,WAAW,CAAC,CAACM,GAAG,CAAC,CAAC,CAACC,SAAS,EAAEC,MAAM,CAAC,KAAK,CACvDA,MAAM,CAACC,OAAO,EACdF,SAAS,CACV,CAAC,CACH;EAED,MAAMG,OAAO,GAAGC,QAAQ,CAAC,MAAMb,QAAQ,CAACc,IAAI,CAAC,aAAa,CAAC,EAAE,EAAE,CAAC;EAEhE,MAAMC,qBAAqB,GAAG,CAAC,GAAGZ,YAAY,CAAC,CAC5Ca,OAAO,EAAE,CAAC;EAAA,CACVC,IAAI,CAAEC,WAAW,IAAKA,WAAW,CAACP,OAAO,KAAKC,OAAO,CAAC;EAEzD;EACA;EACA,IAAIG,qBAAqB,KAAKI,SAAS,EAAE;IACvC,OAAOJ,qBAAqB;;EAG9B,MAAMK,OAAO,GAAGL,qBAAqB,IAAIX,eAAe,CAACiB,GAAG,CAACT,OAAO,CAAC;EAErE,IAAIQ,OAAO,KAAKD,SAAS,EAAE;IACzB,IAAArB,QAAA,CAAAwB,uBAAuB,EAACrB,WAAW,EAAEW,OAAO,CAAC;;EAG/C,MAAMW,gBAAgB,GAAGrB,WAAW,CAACkB,OAAO,CAAC;EAE7C,OAAO;IAAEA,OAAO;IAAEI,IAAI,EAAED,gBAAgB,CAACC;EAAI,CAAE;AACjD;AAlCAC,OAAA,CAAA1B,qBAAA,GAAAA,qBAAA;AAoCO,eAAe2B,wBAAwBA,CAC5CC,OAAe,EACf3B,QAA0B,EAC1BC,WAAmB;EAEnB,MAAM2B,cAAc,GAAI,MAAM5B,QAAQ,CAACc,IAAI,CAAC,aAAa,EAAE,CACzDa,OAAO,EACP,QAAQ,CACT,CAAY;EACb,MAAME,gBAAgB,GAAGD,cAAc,CAACE,UAAU,CAAC,IAAI,CAAC,GACpDF,cAAc,CAACG,KAAK,CAAC,CAAC,CAAC,GACvBH,cAAc;EAClB,IAAIC,gBAAgB,CAACG,MAAM,KAAK,CAAC,EAAE;IACjC,MAAM,IAAIrC,SAAA,CAAAsC,2BAA2B,CACnCpC,WAAA,CAAAqC,UAAU,EACV,eAAeP,OAAO;0BACF1B,WAAW,GAAG,CACnC;;EAEH,OAAO4B,gBAAgB;AACzB;AApBAJ,OAAA,CAAAC,wBAAA,GAAAA,wBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}