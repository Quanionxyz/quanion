{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getLibraryLinks = void 0;\nconst constants_1 = require(\"../constants\");\nconst errors_1 = require(\"../errors\");\nasync function getLibraryLinks(contractInformation, libraries) {\n  const allLibraries = getLibraryNames(contractInformation.contract.evm.bytecode.linkReferences);\n  const detectableLibraries = getLibraryNames(contractInformation.contract.evm.deployedBytecode.linkReferences);\n  const undetectableLibraries = allLibraries.filter(lib => !detectableLibraries.some(detectableLib => {\n    return detectableLib.sourceName === lib.sourceName && detectableLib.libName === lib.libName;\n  }));\n  // Resolve and normalize library links given by user\n  const normalizedLibraries = await normalizeLibraries(allLibraries, detectableLibraries, undetectableLibraries, libraries, contractInformation.contractName);\n  // Merge library links\n  const mergedLibraryLinks = mergeLibraries(normalizedLibraries, contractInformation.libraryLinks);\n  const mergedLibraries = getLibraryNames(mergedLibraryLinks);\n  if (mergedLibraries.length < allLibraries.length) {\n    // TODO: update message to help solve this problem\n    const missingLibraries = allLibraries.filter(lib => !mergedLibraries.some(mergedLib => {\n      return lib.sourceName === mergedLib.sourceName && lib.libName === mergedLib.libName;\n    }));\n    const missingLibraryNames = missingLibraries.map(({\n      sourceName,\n      libName\n    }) => `${sourceName}:${libName}`).map(x => `  * ${x}`).join(\"\\n\");\n    let message = `The contract ${contractInformation.sourceName}:${contractInformation.contractName} has one or more library addresses that cannot be detected from deployed bytecode.\nThis can occur if the library is only called in the contract constructor. The missing libraries are:\n${missingLibraryNames}`;\n    // We want to distinguish the case when no undetectable libraries were provided to give a more helpful message.\n    if (missingLibraries.length === undetectableLibraries.length) {\n      message += `\n\nVisit https://hardhat.org/hardhat-runner/plugins/nomiclabs-hardhat-etherscan#libraries-with-undetectable-addresses to learn how to solve this.`;\n    } else {\n      message += `\n\nTo solve this, you can add them to your --libraries dictionary with their corresponding addresses.`;\n    }\n    throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, message);\n  }\n  return {\n    libraryLinks: mergedLibraryLinks,\n    undetectableLibraries\n  };\n}\nexports.getLibraryLinks = getLibraryLinks;\nfunction mergeLibraries(normalizedLibraries, detectedLibraries) {\n  const conflicts = [];\n  for (const [sourceName, libraries] of Object.entries(normalizedLibraries)) {\n    for (const [libName, libAddress] of Object.entries(libraries)) {\n      if (sourceName in detectedLibraries && libName in detectedLibraries[sourceName]) {\n        const detectedAddress = detectedLibraries[sourceName][libName];\n        // Our detection logic encodes bytes into lowercase hex.\n        if (libAddress.toLowerCase() !== detectedAddress) {\n          conflicts.push({\n            library: `${sourceName}:${libName}`,\n            detectedAddress,\n            inputAddress: libAddress\n          });\n        }\n      }\n    }\n  }\n  if (conflicts.length > 0) {\n    const conflictDescriptions = conflicts.map(conflict => `  * ${conflict.library}\n    given address: ${conflict.inputAddress}\n    detected address: ${conflict.detectedAddress}`).join(\"\\n\");\n    throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `The following detected library addresses are different from the ones provided:\n${conflictDescriptions}\n\nYou can either fix these addresses in your libraries dictionary or simply remove them to let the plugin autodetect them.`);\n  }\n  const mergedLibraries = {};\n  addLibraries(mergedLibraries, normalizedLibraries);\n  addLibraries(mergedLibraries, detectedLibraries);\n  return mergedLibraries;\n}\nfunction addLibraries(targetLibraries, newLibraries) {\n  for (const [sourceName, libraries] of Object.entries(newLibraries)) {\n    if (targetLibraries[sourceName] === undefined) {\n      targetLibraries[sourceName] = {};\n    }\n    for (const [libName, libAddress] of Object.entries(libraries)) {\n      targetLibraries[sourceName][libName] = libAddress;\n    }\n  }\n}\nasync function normalizeLibraries(allLibraries, detectableLibraries, undetectableLibraries, libraries, contractName) {\n  const {\n    isAddress\n  } = await Promise.resolve().then(() => __importStar(require(\"@ethersproject/address\")));\n  const libraryFQNs = new Set();\n  const normalizedLibraries = {};\n  for (const [linkedLibraryName, linkedLibraryAddress] of Object.entries(libraries)) {\n    if (!isAddress(linkedLibraryAddress)) {\n      throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `You gave a link for the contract ${contractName} with the library ${linkedLibraryName}, but provided this invalid address: ${linkedLibraryAddress}`);\n    }\n    const neededLibrary = lookupLibrary(allLibraries, detectableLibraries, undetectableLibraries, linkedLibraryName, contractName);\n    const neededLibraryFQN = `${neededLibrary.sourceName}:${neededLibrary.libName}`;\n    // The only way for this library to be already mapped is\n    // for it to be given twice in the libraries user input:\n    // once as a library name and another as a fully qualified library name.\n    if (libraryFQNs.has(neededLibraryFQN)) {\n      throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `The library names ${neededLibrary.libName} and ${neededLibraryFQN} refer to the same library and were given as two entries in the libraries dictionary.\nRemove one of them and review your libraries dictionary before proceeding.`);\n    }\n    libraryFQNs.add(neededLibraryFQN);\n    if (normalizedLibraries[neededLibrary.sourceName] === undefined) {\n      normalizedLibraries[neededLibrary.sourceName] = {};\n    }\n    normalizedLibraries[neededLibrary.sourceName][neededLibrary.libName] = linkedLibraryAddress;\n  }\n  return normalizedLibraries;\n}\nfunction lookupLibrary(allLibraries, detectableLibraries, undetectableLibraries, linkedLibraryName, contractName) {\n  const matchingLibraries = allLibraries.filter(lib => {\n    return lib.libName === linkedLibraryName || `${lib.sourceName}:${lib.libName}` === linkedLibraryName;\n  });\n  if (matchingLibraries.length === 0) {\n    let detailedMessage = \"\";\n    if (allLibraries.length > 0) {\n      const undetectableLibraryFQNames = undetectableLibraries.map(lib => `${lib.sourceName}:${lib.libName}`).map(x => `  * ${x}`).join(\"\\n\");\n      const detectableLibraryFQNames = detectableLibraries.map(lib => `${lib.sourceName}:${lib.libName}`).map(x => `  * ${x} (optional)`).join(\"\\n\");\n      detailedMessage += `This contract uses the following external libraries:\n${undetectableLibraryFQNames}\n${detectableLibraryFQNames}`;\n      if (detectableLibraries.length > 0) {\n        detailedMessage += `\nLibraries marked as optional don't need to be specified since their addresses are autodetected by the plugin.`;\n      }\n    } else {\n      detailedMessage += \"This contract doesn't use any external libraries.\";\n    }\n    throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `You gave an address for the library ${linkedLibraryName} in the libraries dictionary, which is not one of the libraries of contract ${contractName}.\n${detailedMessage}`);\n  }\n  if (matchingLibraries.length > 1) {\n    const matchingLibrariesFQNs = matchingLibraries.map(({\n      sourceName,\n      libName\n    }) => `${sourceName}:${libName}`).map(x => `  * ${x}`).join(\"\\n\");\n    throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `The library name ${linkedLibraryName} is ambiguous for the contract ${contractName}.\nIt may resolve to one of the following libraries:\n${matchingLibrariesFQNs}\n\nTo fix this, choose one of these fully qualified library names and replace it in your libraries dictionary.`);\n  }\n  const [neededLibrary] = matchingLibraries;\n  return neededLibrary;\n}\nfunction getLibraryNames(libraries) {\n  const libraryNames = [];\n  for (const [sourceName, sourceLibraries] of Object.entries(libraries)) {\n    for (const libName of Object.keys(sourceLibraries)) {\n      libraryNames.push({\n        sourceName,\n        libName\n      });\n    }\n  }\n  return libraryNames;\n}","map":{"version":3,"names":["constants_1","require","errors_1","getLibraryLinks","contractInformation","libraries","allLibraries","getLibraryNames","contract","evm","bytecode","linkReferences","detectableLibraries","deployedBytecode","undetectableLibraries","filter","lib","some","detectableLib","sourceName","libName","normalizedLibraries","normalizeLibraries","contractName","mergedLibraryLinks","mergeLibraries","libraryLinks","mergedLibraries","length","missingLibraries","mergedLib","missingLibraryNames","map","x","join","message","HardhatEtherscanPluginError","pluginName","exports","detectedLibraries","conflicts","Object","entries","libAddress","detectedAddress","toLowerCase","push","library","inputAddress","conflictDescriptions","conflict","addLibraries","targetLibraries","newLibraries","undefined","isAddress","Promise","resolve","then","__importStar","libraryFQNs","Set","linkedLibraryName","linkedLibraryAddress","neededLibrary","lookupLibrary","neededLibraryFQN","has","add","matchingLibraries","detailedMessage","undetectableLibraryFQNames","detectableLibraryFQNames","matchingLibrariesFQNs","libraryNames","sourceLibraries","keys"],"sources":["/workspace/quanion/node_modules/@nomiclabs/hardhat-etherscan/src/solc/libraries.ts"],"sourcesContent":["import { pluginName } from \"../constants\";\n\nimport { HardhatEtherscanPluginError } from \"../errors\";\nimport { ContractInformation, ResolvedLinks } from \"./bytecode\";\n\nexport interface Libraries {\n  // This may be a fully qualified name\n  [libraryName: string]: string;\n}\n\nexport type LibraryNames = Array<{\n  sourceName: string;\n  libName: string;\n}>;\n\ninterface LibrariesStdInput {\n  [sourceName: string]: {\n    [libraryName: string]: any;\n  };\n}\n\nexport async function getLibraryLinks(\n  contractInformation: ContractInformation,\n  libraries: Libraries\n) {\n  const allLibraries = getLibraryNames(\n    contractInformation.contract.evm.bytecode.linkReferences\n  );\n  const detectableLibraries = getLibraryNames(\n    contractInformation.contract.evm.deployedBytecode.linkReferences\n  );\n  const undetectableLibraries: LibraryNames = allLibraries.filter(\n    (lib) =>\n      !detectableLibraries.some((detectableLib) => {\n        return (\n          detectableLib.sourceName === lib.sourceName &&\n          detectableLib.libName === lib.libName\n        );\n      })\n  );\n\n  // Resolve and normalize library links given by user\n  const normalizedLibraries = await normalizeLibraries(\n    allLibraries,\n    detectableLibraries,\n    undetectableLibraries,\n    libraries,\n    contractInformation.contractName\n  );\n\n  // Merge library links\n  const mergedLibraryLinks = mergeLibraries(\n    normalizedLibraries,\n    contractInformation.libraryLinks\n  );\n\n  const mergedLibraries = getLibraryNames(mergedLibraryLinks);\n  if (mergedLibraries.length < allLibraries.length) {\n    // TODO: update message to help solve this problem\n    const missingLibraries = allLibraries.filter(\n      (lib) =>\n        !mergedLibraries.some((mergedLib) => {\n          return (\n            lib.sourceName === mergedLib.sourceName &&\n            lib.libName === mergedLib.libName\n          );\n        })\n    );\n    const missingLibraryNames = missingLibraries\n      .map(({ sourceName, libName }) => `${sourceName}:${libName}`)\n      .map((x) => `  * ${x}`)\n      .join(\"\\n\");\n    let message = `The contract ${contractInformation.sourceName}:${contractInformation.contractName} has one or more library addresses that cannot be detected from deployed bytecode.\nThis can occur if the library is only called in the contract constructor. The missing libraries are:\n${missingLibraryNames}`;\n    // We want to distinguish the case when no undetectable libraries were provided to give a more helpful message.\n    if (missingLibraries.length === undetectableLibraries.length) {\n      message += `\n\nVisit https://hardhat.org/hardhat-runner/plugins/nomiclabs-hardhat-etherscan#libraries-with-undetectable-addresses to learn how to solve this.`;\n    } else {\n      message += `\n\nTo solve this, you can add them to your --libraries dictionary with their corresponding addresses.`;\n    }\n    throw new HardhatEtherscanPluginError(pluginName, message);\n  }\n  return { libraryLinks: mergedLibraryLinks, undetectableLibraries };\n}\n\nfunction mergeLibraries(\n  normalizedLibraries: ResolvedLinks,\n  detectedLibraries: ResolvedLinks\n): ResolvedLinks {\n  const conflicts = [];\n  for (const [sourceName, libraries] of Object.entries(normalizedLibraries)) {\n    for (const [libName, libAddress] of Object.entries(libraries)) {\n      if (\n        sourceName in detectedLibraries &&\n        libName in detectedLibraries[sourceName]\n      ) {\n        const detectedAddress = detectedLibraries[sourceName][libName];\n        // Our detection logic encodes bytes into lowercase hex.\n        if (libAddress.toLowerCase() !== detectedAddress) {\n          conflicts.push({\n            library: `${sourceName}:${libName}`,\n            detectedAddress,\n            inputAddress: libAddress,\n          });\n        }\n      }\n    }\n  }\n\n  if (conflicts.length > 0) {\n    const conflictDescriptions = conflicts\n      .map(\n        (conflict) =>\n          `  * ${conflict.library}\n    given address: ${conflict.inputAddress}\n    detected address: ${conflict.detectedAddress}`\n      )\n      .join(\"\\n\");\n    throw new HardhatEtherscanPluginError(\n      pluginName,\n      `The following detected library addresses are different from the ones provided:\n${conflictDescriptions}\n\nYou can either fix these addresses in your libraries dictionary or simply remove them to let the plugin autodetect them.`\n    );\n  }\n\n  const mergedLibraries: ResolvedLinks = {};\n  addLibraries(mergedLibraries, normalizedLibraries);\n  addLibraries(mergedLibraries, detectedLibraries);\n  return mergedLibraries;\n}\n\nfunction addLibraries(\n  targetLibraries: ResolvedLinks,\n  newLibraries: ResolvedLinks\n) {\n  for (const [sourceName, libraries] of Object.entries(newLibraries)) {\n    if (targetLibraries[sourceName] === undefined) {\n      targetLibraries[sourceName] = {};\n    }\n    for (const [libName, libAddress] of Object.entries(libraries)) {\n      targetLibraries[sourceName][libName] = libAddress;\n    }\n  }\n}\n\nasync function normalizeLibraries(\n  allLibraries: LibraryNames,\n  detectableLibraries: LibraryNames,\n  undetectableLibraries: LibraryNames,\n  libraries: Libraries,\n  contractName: string\n) {\n  const { isAddress } = await import(\"@ethersproject/address\");\n\n  const libraryFQNs: Set<string> = new Set();\n  const normalizedLibraries: ResolvedLinks = {};\n  for (const [linkedLibraryName, linkedLibraryAddress] of Object.entries(\n    libraries\n  )) {\n    if (!isAddress(linkedLibraryAddress)) {\n      throw new HardhatEtherscanPluginError(\n        pluginName,\n        `You gave a link for the contract ${contractName} with the library ${linkedLibraryName}, but provided this invalid address: ${linkedLibraryAddress}`\n      );\n    }\n\n    const neededLibrary = lookupLibrary(\n      allLibraries,\n      detectableLibraries,\n      undetectableLibraries,\n      linkedLibraryName,\n      contractName\n    );\n    const neededLibraryFQN = `${neededLibrary.sourceName}:${neededLibrary.libName}`;\n\n    // The only way for this library to be already mapped is\n    // for it to be given twice in the libraries user input:\n    // once as a library name and another as a fully qualified library name.\n    if (libraryFQNs.has(neededLibraryFQN)) {\n      throw new HardhatEtherscanPluginError(\n        pluginName,\n        `The library names ${neededLibrary.libName} and ${neededLibraryFQN} refer to the same library and were given as two entries in the libraries dictionary.\nRemove one of them and review your libraries dictionary before proceeding.`\n      );\n    }\n\n    libraryFQNs.add(neededLibraryFQN);\n    if (normalizedLibraries[neededLibrary.sourceName] === undefined) {\n      normalizedLibraries[neededLibrary.sourceName] = {};\n    }\n    normalizedLibraries[neededLibrary.sourceName][neededLibrary.libName] =\n      linkedLibraryAddress;\n  }\n  return normalizedLibraries;\n}\n\nfunction lookupLibrary(\n  allLibraries: LibraryNames,\n  detectableLibraries: LibraryNames,\n  undetectableLibraries: LibraryNames,\n  linkedLibraryName: string,\n  contractName: string\n) {\n  const matchingLibraries = allLibraries.filter((lib) => {\n    return (\n      lib.libName === linkedLibraryName ||\n      `${lib.sourceName}:${lib.libName}` === linkedLibraryName\n    );\n  });\n\n  if (matchingLibraries.length === 0) {\n    let detailedMessage = \"\";\n    if (allLibraries.length > 0) {\n      const undetectableLibraryFQNames = undetectableLibraries\n        .map((lib) => `${lib.sourceName}:${lib.libName}`)\n        .map((x) => `  * ${x}`)\n        .join(\"\\n\");\n      const detectableLibraryFQNames = detectableLibraries\n        .map((lib) => `${lib.sourceName}:${lib.libName}`)\n        .map((x) => `  * ${x} (optional)`)\n        .join(\"\\n\");\n      detailedMessage += `This contract uses the following external libraries:\n${undetectableLibraryFQNames}\n${detectableLibraryFQNames}`;\n      if (detectableLibraries.length > 0) {\n        detailedMessage += `\nLibraries marked as optional don't need to be specified since their addresses are autodetected by the plugin.`;\n      }\n    } else {\n      detailedMessage += \"This contract doesn't use any external libraries.\";\n    }\n    throw new HardhatEtherscanPluginError(\n      pluginName,\n      `You gave an address for the library ${linkedLibraryName} in the libraries dictionary, which is not one of the libraries of contract ${contractName}.\n${detailedMessage}`\n    );\n  }\n\n  if (matchingLibraries.length > 1) {\n    const matchingLibrariesFQNs = matchingLibraries\n      .map(({ sourceName, libName }) => `${sourceName}:${libName}`)\n      .map((x) => `  * ${x}`)\n      .join(\"\\n\");\n    throw new HardhatEtherscanPluginError(\n      pluginName,\n      `The library name ${linkedLibraryName} is ambiguous for the contract ${contractName}.\nIt may resolve to one of the following libraries:\n${matchingLibrariesFQNs}\n\nTo fix this, choose one of these fully qualified library names and replace it in your libraries dictionary.`\n    );\n  }\n\n  const [neededLibrary] = matchingLibraries;\n  return neededLibrary;\n}\n\nfunction getLibraryNames(libraries: LibrariesStdInput): LibraryNames {\n  const libraryNames: LibraryNames = [];\n  for (const [sourceName, sourceLibraries] of Object.entries(libraries)) {\n    for (const libName of Object.keys(sourceLibraries)) {\n      libraryNames.push({ sourceName, libName });\n    }\n  }\n\n  return libraryNames;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}