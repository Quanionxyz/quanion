{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst task_names_1 = require(\"hardhat/builtin-tasks/task-names\");\nconst config_1 = require(\"hardhat/config\");\nconst contract_names_1 = require(\"hardhat/utils/contract-names\");\nconst path_1 = __importDefault(require(\"path\"));\nconst semver_1 = __importDefault(require(\"semver\"));\nconst ABIEncoder_1 = require(\"./ABIEncoder\");\nconst config_2 = require(\"./config\");\nconst constants_1 = require(\"./constants\");\nconst EtherscanService_1 = require(\"./etherscan/EtherscanService\");\nconst EtherscanVerifyContractRequest_1 = require(\"./etherscan/EtherscanVerifyContractRequest\");\nconst ChainConfig_1 = require(\"./ChainConfig\");\nconst prober_1 = require(\"./network/prober\");\nconst resolveEtherscanApiKey_1 = require(\"./resolveEtherscanApiKey\");\nconst bytecode_1 = require(\"./solc/bytecode\");\nconst libraries_1 = require(\"./solc/libraries\");\nconst metadata_1 = require(\"./solc/metadata\");\nconst version_1 = require(\"./solc/version\");\nrequire(\"./type-extensions\");\nconst util_1 = require(\"./util\");\nconst errors_1 = require(\"./errors\");\n(0, config_1.extendConfig)(config_2.etherscanConfigExtender);\nconst verify = async ({\n  address,\n  constructorArgsParams,\n  constructorArgs: constructorArgsModule,\n  contract,\n  libraries: librariesModule,\n  listNetworks,\n  noCompile\n}, {\n  config,\n  run\n}) => {\n  if (listNetworks) {\n    await (0, util_1.printSupportedNetworks)(config.etherscan.customChains);\n    return;\n  }\n  if (address === undefined) {\n    throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, \"You didn’t provide any address. Please re-run the 'verify' task with the address of the contract you want to verify.\");\n  }\n  (0, config_2.verifyAllowedChains)(config.etherscan);\n  const constructorArguments = await run(constants_1.TASK_VERIFY_GET_CONSTRUCTOR_ARGUMENTS, {\n    constructorArgsModule,\n    constructorArgsParams\n  });\n  const libraries = await run(constants_1.TASK_VERIFY_GET_LIBRARIES, {\n    librariesModule\n  });\n  return run(constants_1.TASK_VERIFY_VERIFY, {\n    address,\n    constructorArguments,\n    contract,\n    libraries,\n    noCompile\n  });\n};\nconst verifySubtask = async ({\n  address,\n  constructorArguments,\n  contract: contractFQN,\n  libraries,\n  noCompile\n}, {\n  config,\n  network,\n  run\n}) => {\n  const {\n    etherscan\n  } = config;\n  const {\n    isAddress\n  } = await Promise.resolve().then(() => __importStar(require(\"@ethersproject/address\")));\n  if (!isAddress(address)) {\n    throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `${address} is an invalid address.`);\n  }\n  // This can only happen if the subtask is invoked from within Hardhat by a user script or another task.\n  if (!Array.isArray(constructorArguments)) {\n    throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `The constructorArguments parameter should be an array.\nIf your constructor has no arguments pass an empty array. E.g:\n\n  await run(\"${constants_1.TASK_VERIFY_VERIFY}\", {\n    <other args>,\n    constructorArguments: []\n  };`);\n  }\n  const compilerVersions = await run(constants_1.TASK_VERIFY_GET_COMPILER_VERSIONS);\n  const {\n    network: verificationNetwork,\n    urls: etherscanAPIEndpoints\n  } = await run(constants_1.TASK_VERIFY_GET_ETHERSCAN_ENDPOINT);\n  const etherscanAPIKey = (0, resolveEtherscanApiKey_1.resolveEtherscanApiKey)(etherscan.apiKey, verificationNetwork);\n  const alreadyVerified = await (0, EtherscanService_1.isAlreadyVerified)(etherscanAPIEndpoints.apiURL, etherscanAPIKey, address);\n  if (alreadyVerified) {\n    console.log(`The contract ${address} has already been verified`);\n    return;\n  }\n  const deployedBytecodeHex = await (0, prober_1.retrieveContractBytecode)(address, network.provider, network.name);\n  const deployedBytecode = new bytecode_1.Bytecode(deployedBytecodeHex);\n  const inferredSolcVersion = deployedBytecode.getInferredSolcVersion();\n  const matchingCompilerVersions = compilerVersions.filter(version => {\n    return semver_1.default.satisfies(version, inferredSolcVersion);\n  });\n  if (matchingCompilerVersions.length === 0 &&\n  // don't error if the bytecode appears to be OVM bytecode, because we can't infer a specific OVM solc version from the bytecode\n  !deployedBytecode.isOvmInferred()) {\n    let configuredCompilersFragment;\n    if (compilerVersions.length > 1) {\n      configuredCompilersFragment = `your configured compiler versions are: ${compilerVersions.join(\", \")}`;\n    } else {\n      configuredCompilersFragment = `your configured compiler version is: ${compilerVersions[0]}`;\n    }\n    const message = `The contract you want to verify was compiled with solidity ${inferredSolcVersion}, but ${configuredCompilersFragment}.\n\nPossible causes are:\n  - You are not in the same commit that was used to deploy the contract.\n  - Wrong compiler version selected in hardhat config.\n  - The given address is wrong.\n  - The selected network (${network.name}) is wrong.`;\n    throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, message);\n  }\n  // Make sure that contract artifacts are up-to-date.\n  if (!noCompile) {\n    await run(task_names_1.TASK_COMPILE);\n  }\n  const contractInformation = await run(constants_1.TASK_VERIFY_GET_CONTRACT_INFORMATION, {\n    contractFQN,\n    deployedBytecode,\n    matchingCompilerVersions,\n    libraries\n  });\n  // Override solc version based on hardhat config if verifying for the OVM. This is used instead of fetching the\n  // full version name from a solc bin JSON file (as is done for EVM solc in src/solc/version.ts) because it's\n  // simpler and avoids a network request we don't need. This is ok because the solc version specified in the OVM\n  // config always equals the full solc version\n  if (deployedBytecode.isOvmInferred()) {\n    // We cast to this custom type here instead of using `extendConfig` to avoid always mutating the HardhatConfig\n    // type. We don't want that type to always contain the `ovm` field, because users only using hardhat-etherscan\n    // without the Optimism plugin should not have that field in their type definitions\n    const configCopy = {\n      ...config\n    };\n    const ovmSolcVersion = configCopy.ovm?.solcVersion;\n    if (ovmSolcVersion === undefined) {\n      const message = `It looks like you are verifying an OVM contract, but do not have an OVM solcVersion specified in the hardhat config.`;\n      throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, message);\n    }\n    contractInformation.solcVersion = `v${ovmSolcVersion}`; // Etherscan requires the leading `v` before the version string\n  }\n  const deployArgumentsEncoded = await (0, ABIEncoder_1.encodeArguments)(contractInformation.contract.abi, contractInformation.sourceName, contractInformation.contractName, constructorArguments);\n  // If OVM, the full version string was already read from the hardhat config. If solc, get the full version string\n  const solcFullVersion = deployedBytecode.isOvmInferred() ? contractInformation.solcVersion : await (0, version_1.getLongVersion)(contractInformation.solcVersion);\n  const minimumBuild = await run(constants_1.TASK_VERIFY_GET_MINIMUM_BUILD, {\n    sourceName: contractInformation.sourceName\n  });\n  const success = await run(constants_1.TASK_VERIFY_VERIFY_MINIMUM_BUILD, {\n    minimumBuild,\n    contractInformation,\n    etherscanAPIEndpoints,\n    address,\n    etherscanAPIKey,\n    solcFullVersion,\n    deployArgumentsEncoded\n  });\n  if (success) {\n    return;\n  }\n  // Fallback verification\n  const verificationStatus = await attemptVerification(etherscanAPIEndpoints, contractInformation, address, etherscanAPIKey, contractInformation.compilerInput, solcFullVersion, deployArgumentsEncoded);\n  if (verificationStatus.isVerificationSuccess()) {\n    const contractURL = (0, util_1.buildContractUrl)(etherscanAPIEndpoints.browserURL, address);\n    console.log(`Successfully verified full build of contract ${contractInformation.contractName} on Etherscan.\n${contractURL}`);\n    return;\n  }\n  let errorMessage = `The contract verification failed.\nReason: ${verificationStatus.message}`;\n  if (contractInformation.undetectableLibraries.length > 0) {\n    const undetectableLibraryNames = contractInformation.undetectableLibraries.map(({\n      sourceName,\n      libName\n    }) => `${sourceName}:${libName}`).map(x => `  * ${x}`).join(\"\\n\");\n    errorMessage += `\nThis contract makes use of libraries whose addresses are undetectable by the plugin.\nKeep in mind that this verification failure may be due to passing in the wrong\naddress for one of these libraries:\n${undetectableLibraryNames}`;\n  }\n  throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, errorMessage);\n};\n(0, config_1.subtask)(constants_1.TASK_VERIFY_GET_CONSTRUCTOR_ARGUMENTS).addParam(\"constructorArgsParams\", undefined, undefined, config_1.types.any).addOptionalParam(\"constructorArgsModule\", undefined, undefined, config_1.types.inputFile).setAction(async ({\n  constructorArgsModule,\n  constructorArgsParams\n}) => {\n  if (typeof constructorArgsModule !== \"string\") {\n    return constructorArgsParams;\n  }\n  const constructorArgsModulePath = path_1.default.resolve(process.cwd(), constructorArgsModule);\n  try {\n    const constructorArguments = (await Promise.resolve().then(() => __importStar(require(constructorArgsModulePath)))).default;\n    if (!Array.isArray(constructorArguments)) {\n      throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `The module ${constructorArgsModulePath} doesn't export a list. The module should look like this:\n\n  module.exports = [ arg1, arg2, ... ];`);\n    }\n    return constructorArguments;\n  } catch (error) {\n    throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `Importing the module for the constructor arguments list failed.\nReason: ${error.message}`, error);\n  }\n});\n(0, config_1.subtask)(constants_1.TASK_VERIFY_GET_LIBRARIES).addOptionalParam(\"librariesModule\", undefined, undefined, config_1.types.inputFile).setAction(async ({\n  librariesModule\n}) => {\n  if (typeof librariesModule !== \"string\") {\n    return {};\n  }\n  const librariesModulePath = path_1.default.resolve(process.cwd(), librariesModule);\n  try {\n    const libraries = (await Promise.resolve().then(() => __importStar(require(librariesModulePath)))).default;\n    if (typeof libraries !== \"object\" || Array.isArray(libraries)) {\n      throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `The module ${librariesModulePath} doesn't export a dictionary. The module should look like this:\n\n  module.exports = { lib1: \"0x...\", lib2: \"0x...\", ... };`);\n    }\n    return libraries;\n  } catch (error) {\n    throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `Importing the module for the libraries dictionary failed.\nReason: ${error.message}`, error);\n  }\n});\nasync function attemptVerification(etherscanAPIEndpoints, contractInformation, contractAddress, etherscanAPIKey, compilerInput, solcFullVersion, deployArgumentsEncoded) {\n  // Ensure the linking information is present in the compiler input;\n  compilerInput.settings.libraries = contractInformation.libraryLinks;\n  const request = (0, EtherscanVerifyContractRequest_1.toVerifyRequest)({\n    apiKey: etherscanAPIKey,\n    contractAddress,\n    sourceCode: JSON.stringify(compilerInput),\n    sourceName: contractInformation.sourceName,\n    contractName: contractInformation.contractName,\n    compilerVersion: solcFullVersion,\n    constructorArguments: deployArgumentsEncoded\n  });\n  const response = await (0, EtherscanService_1.verifyContract)(etherscanAPIEndpoints.apiURL, request);\n  console.log(`Successfully submitted source code for contract\n${contractInformation.sourceName}:${contractInformation.contractName} at ${contractAddress}\nfor verification on the block explorer. Waiting for verification result...\n`);\n  const pollRequest = (0, EtherscanVerifyContractRequest_1.toCheckStatusRequest)({\n    apiKey: etherscanAPIKey,\n    guid: response.message\n  });\n  // Compilation is bound to take some time so there's no sense in requesting status immediately.\n  await (0, EtherscanService_1.delay)(700);\n  const verificationStatus = await (0, EtherscanService_1.getVerificationStatus)(etherscanAPIEndpoints.apiURL, pollRequest);\n  if (verificationStatus.isVerificationFailure() || verificationStatus.isVerificationSuccess()) {\n    return verificationStatus;\n  }\n  // Reaching this point shouldn't be possible unless the API is behaving in a new way.\n  throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `The API responded with an unexpected message.\nContract verification may have succeeded and should be checked manually.\nMessage: ${verificationStatus.message}`, undefined, true);\n}\nconst getMinimumBuild = async function ({\n  sourceName\n}, {\n  run\n}) {\n  const dependencyGraph = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH, {\n    sourceNames: [sourceName]\n  });\n  const resolvedFiles = dependencyGraph.getResolvedFiles().filter(resolvedFile => {\n    return resolvedFile.sourceName === sourceName;\n  });\n  assertHardhatPluginInvariant(resolvedFiles.length === 1, `The plugin found an unexpected number of files for this contract.`);\n  const compilationJob = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE, {\n    dependencyGraph,\n    file: resolvedFiles[0]\n  });\n  const build = await run(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_JOB, {\n    compilationJob,\n    compilationJobs: [compilationJob],\n    compilationJobIndex: 0,\n    emitsArtifacts: false,\n    quiet: true\n  });\n  return build;\n};\nasync function inferContract(artifacts, network, matchingCompilerVersions, deployedBytecode) {\n  const contractMatches = await (0, bytecode_1.lookupMatchingBytecode)(artifacts, matchingCompilerVersions, deployedBytecode);\n  if (contractMatches.length === 0) {\n    const message = `The address provided as argument contains a contract, but its bytecode doesn't match any of your local contracts.\n\nPossible causes are:\n  - Contract code changed after the deployment was executed. This includes code for seemingly unrelated contracts.\n  - A solidity file was added, moved, deleted or renamed after the deployment was executed. This includes files for seemingly unrelated contracts.\n  - Solidity compiler settings were modified after the deployment was executed (like the optimizer, target EVM, etc.).\n  - The given address is wrong.\n  - The selected network (${network.name}) is wrong.`;\n    throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, message);\n  }\n  if (contractMatches.length > 1) {\n    const nameList = contractMatches.map(contract => {\n      return `${contract.sourceName}:${contract.contractName}`;\n    }).map(fqName => `  * ${fqName}`).join(\"\\n\");\n    const message = `More than one contract was found to match the deployed bytecode.\nPlease use the contract parameter with one of the following contracts:\n${nameList}\n\nFor example:\n\n  hardhat verify --contract contracts/Example.sol:ExampleContract <other args>\n\nIf you are running the verify subtask from within Hardhat instead:\n\n  await run(\"${constants_1.TASK_VERIFY_VERIFY}\", {\n    <other args>,\n    contract: \"contracts/Example.sol:ExampleContract\"\n  };`;\n    throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, message, undefined, true);\n  }\n  return contractMatches[0];\n}\n(0, config_1.subtask)(constants_1.TASK_VERIFY_GET_COMPILER_VERSIONS).setAction(async (_, {\n  config\n}) => {\n  const compilerVersions = config.solidity.compilers.map(c => c.version);\n  if (config.solidity.overrides !== undefined) {\n    for (const {\n      version\n    } of Object.values(config.solidity.overrides)) {\n      compilerVersions.push(version);\n    }\n  }\n  // Etherscan only supports solidity versions higher than or equal to v0.4.11.\n  // See https://etherscan.io/solcversions\n  const supportedSolcVersionRange = \">=0.4.11\";\n  if (compilerVersions.some(version => {\n    return !semver_1.default.satisfies(version, supportedSolcVersionRange);\n  })) {\n    throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `Etherscan only supports compiler versions 0.4.11 and higher.\nSee https://etherscan.io/solcversions for more information.`);\n  }\n  return compilerVersions;\n});\n(0, config_1.subtask)(constants_1.TASK_VERIFY_GET_ETHERSCAN_ENDPOINT).setAction(async (_, {\n  config,\n  network\n}) => (0, prober_1.getEtherscanEndpoints)(network.provider, network.name, ChainConfig_1.chainConfig, config.etherscan.customChains));\n(0, config_1.subtask)(constants_1.TASK_VERIFY_GET_CONTRACT_INFORMATION).addParam(\"deployedBytecode\", undefined, undefined, config_1.types.any).addParam(\"matchingCompilerVersions\", undefined, undefined, config_1.types.any).addParam(\"libraries\", undefined, undefined, config_1.types.any).addOptionalParam(\"contractFQN\", undefined, undefined, config_1.types.string).setAction(async ({\n  contractFQN,\n  deployedBytecode,\n  matchingCompilerVersions,\n  libraries\n}, {\n  network,\n  artifacts\n}) => {\n  let contractInformation;\n  if (contractFQN !== undefined) {\n    // Check this particular contract\n    if (!(0, contract_names_1.isFullyQualifiedName)(contractFQN)) {\n      throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `A valid fully qualified name was expected. Fully qualified names look like this: \"contracts/AContract.sol:TheContract\"\nInstead, this name was received: ${contractFQN}`);\n    }\n    if (!(await artifacts.artifactExists(contractFQN))) {\n      throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `The contract ${contractFQN} is not present in your project.`);\n    }\n    // Process BuildInfo here to check version and throw an error if unexpected version is found.\n    const buildInfo = await artifacts.getBuildInfo(contractFQN);\n    if (buildInfo === undefined) {\n      throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `The contract ${contractFQN} is present in your project, but we couldn't find its sources.\nPlease make sure that it has been compiled by Hardhat and that it is written in Solidity.`);\n    }\n    if (!matchingCompilerVersions.includes(buildInfo.solcVersion) && !deployedBytecode.isOvmInferred()) {\n      const inferredSolcVersion = deployedBytecode.getInferredSolcVersion();\n      let versionDetails;\n      if (isVersionRange(inferredSolcVersion)) {\n        versionDetails = `a solidity version in the range ${inferredSolcVersion}`;\n      } else {\n        versionDetails = `the solidity version ${inferredSolcVersion}`;\n      }\n      throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `The contract ${contractFQN} is being compiled with ${buildInfo.solcVersion}.\nHowever, the contract found in the address provided as argument has its bytecode marked with ${versionDetails}.\n\nPossible causes are:\n  - Solidity compiler version settings were modified after the deployment was executed.\n  - The given address is wrong.\n  - The selected network (${network.name}) is wrong.`);\n    }\n    const {\n      sourceName,\n      contractName\n    } = (0, contract_names_1.parseFullyQualifiedName)(contractFQN);\n    contractInformation = await (0, bytecode_1.extractMatchingContractInformation)(sourceName, contractName, buildInfo, deployedBytecode);\n    if (contractInformation === null) {\n      throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `The address provided as argument contains a contract, but its bytecode doesn't match the contract ${contractFQN}.\n\nPossible causes are:\n  - Contract code changed after the deployment was executed. This includes code for seemingly unrelated contracts.\n  - A solidity file was added, moved, deleted or renamed after the deployment was executed. This includes files for seemingly unrelated contracts.\n  - Solidity compiler settings were modified after the deployment was executed (like the optimizer, target EVM, etc.).\n  - The given address is wrong.\n  - The selected network (${network.name}) is wrong.`);\n    }\n  } else {\n    // Infer the contract\n    contractInformation = await inferContract(artifacts, network, matchingCompilerVersions, deployedBytecode);\n  }\n  const {\n    libraryLinks,\n    undetectableLibraries\n  } = await (0, libraries_1.getLibraryLinks)(contractInformation, libraries);\n  return {\n    ...contractInformation,\n    libraryLinks,\n    undetectableLibraries\n  };\n});\n(0, config_1.subtask)(constants_1.TASK_VERIFY_VERIFY_MINIMUM_BUILD).addParam(\"minimumBuild\", undefined, undefined, config_1.types.any).addParam(\"contractInformation\", undefined, undefined, config_1.types.any).addParam(\"etherscanAPIEndpoints\", undefined, undefined, config_1.types.any).addParam(\"address\", undefined, undefined, config_1.types.string).addParam(\"etherscanAPIKey\", undefined, undefined, config_1.types.string).addParam(\"solcFullVersion\", undefined, undefined, config_1.types.string).addParam(\"deployArgumentsEncoded\", undefined, undefined, config_1.types.string).setAction(async ({\n  minimumBuild,\n  contractInformation,\n  etherscanAPIEndpoints,\n  address,\n  etherscanAPIKey,\n  solcFullVersion,\n  deployArgumentsEncoded\n}) => {\n  const minimumBuildContractBytecode = minimumBuild.output.contracts[contractInformation.sourceName][contractInformation.contractName].evm.deployedBytecode.object;\n  const matchedBytecode = contractInformation.compilerOutput.contracts[contractInformation.sourceName][contractInformation.contractName].evm.deployedBytecode.object;\n  if (minimumBuildContractBytecode === matchedBytecode) {\n    const minimumBuildVerificationStatus = await attemptVerification(etherscanAPIEndpoints, contractInformation, address, etherscanAPIKey, minimumBuild.input, solcFullVersion, deployArgumentsEncoded);\n    if (minimumBuildVerificationStatus.isVerificationSuccess()) {\n      const contractURL = (0, util_1.buildContractUrl)(etherscanAPIEndpoints.browserURL, address);\n      console.log(`Successfully verified contract ${contractInformation.contractName} on Etherscan.\n${contractURL}`);\n      return true;\n    }\n    console.log(`We tried verifying your contract ${contractInformation.contractName} without including any unrelated one, but it failed.\nTrying again with the full solc input used to compile and deploy it.\nThis means that unrelated contracts may be displayed on Etherscan...\n`);\n  } else {\n    console.log(`Compiling your contract excluding unrelated contracts did not produce identical bytecode.\nTrying again with the full solc input used to compile and deploy it.\nThis means that unrelated contracts may be displayed on Etherscan...\n`);\n  }\n  return false;\n});\n(0, config_1.subtask)(constants_1.TASK_VERIFY_GET_MINIMUM_BUILD).addParam(\"sourceName\", undefined, undefined, config_1.types.string).setAction(getMinimumBuild);\n(0, config_1.task)(constants_1.TASK_VERIFY, \"Verifies contract on Etherscan\").addOptionalPositionalParam(\"address\", \"Address of the smart contract to verify\").addOptionalParam(\"constructorArgs\", \"File path to a javascript module that exports the list of arguments.\", undefined, config_1.types.inputFile).addOptionalParam(\"contract\", \"Fully qualified name of the contract to verify. \" + \"Skips automatic detection of the contract. \" + \"Use if the deployed bytecode matches more than one contract in your project.\").addOptionalParam(\"libraries\", \"File path to a javascript module that exports the dictionary of library addresses for your contract. \" + \"Use if there are undetectable library addresses in your contract. \" + \"Library addresses are undetectable if they are only used in the constructor for your contract.\", undefined, config_1.types.inputFile).addOptionalVariadicPositionalParam(\"constructorArgsParams\", \"Contract constructor arguments. Ignored if the --constructor-args option is used.\", []).addFlag(\"listNetworks\", \"Print the list of supported networks\").addFlag(\"noCompile\", \"Don't compile before running this task\").setAction(verify);\n(0, config_1.subtask)(constants_1.TASK_VERIFY_VERIFY).addParam(\"address\", undefined, undefined, config_1.types.string).addOptionalParam(\"constructorArguments\", undefined, [], config_1.types.any).addOptionalParam(\"contract\", undefined, undefined, config_1.types.string).addOptionalParam(\"libraries\", undefined, {}, config_1.types.any).addFlag(\"noCompile\", undefined).setAction(verifySubtask);\nfunction assertHardhatPluginInvariant(invariant, message) {\n  if (!invariant) {\n    throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, message, undefined, true);\n  }\n}\nfunction isVersionRange(version) {\n  return version === metadata_1.METADATA_ABSENT_VERSION_RANGE || version === metadata_1.METADATA_PRESENT_SOLC_NOT_FOUND_VERSION_RANGE;\n}","map":{"version":3,"names":["task_names_1","require","config_1","contract_names_1","path_1","__importDefault","semver_1","ABIEncoder_1","config_2","constants_1","EtherscanService_1","EtherscanVerifyContractRequest_1","ChainConfig_1","prober_1","resolveEtherscanApiKey_1","bytecode_1","libraries_1","metadata_1","version_1","util_1","errors_1","extendConfig","etherscanConfigExtender","verify","address","constructorArgsParams","constructorArgs","constructorArgsModule","contract","libraries","librariesModule","listNetworks","noCompile","config","run","printSupportedNetworks","etherscan","customChains","undefined","HardhatEtherscanPluginError","pluginName","verifyAllowedChains","constructorArguments","TASK_VERIFY_GET_CONSTRUCTOR_ARGUMENTS","TASK_VERIFY_GET_LIBRARIES","TASK_VERIFY_VERIFY","verifySubtask","contractFQN","network","isAddress","Promise","resolve","then","__importStar","Array","isArray","compilerVersions","TASK_VERIFY_GET_COMPILER_VERSIONS","verificationNetwork","urls","etherscanAPIEndpoints","TASK_VERIFY_GET_ETHERSCAN_ENDPOINT","etherscanAPIKey","resolveEtherscanApiKey","apiKey","alreadyVerified","isAlreadyVerified","apiURL","console","log","deployedBytecodeHex","retrieveContractBytecode","provider","name","deployedBytecode","Bytecode","inferredSolcVersion","getInferredSolcVersion","matchingCompilerVersions","filter","version","default","satisfies","length","isOvmInferred","configuredCompilersFragment","join","message","TASK_COMPILE","contractInformation","TASK_VERIFY_GET_CONTRACT_INFORMATION","configCopy","ovmSolcVersion","ovm","solcVersion","deployArgumentsEncoded","encodeArguments","abi","sourceName","contractName","solcFullVersion","getLongVersion","minimumBuild","TASK_VERIFY_GET_MINIMUM_BUILD","success","TASK_VERIFY_VERIFY_MINIMUM_BUILD","verificationStatus","attemptVerification","compilerInput","isVerificationSuccess","contractURL","buildContractUrl","browserURL","errorMessage","undetectableLibraries","undetectableLibraryNames","map","libName","x","subtask","addParam","types","any","addOptionalParam","inputFile","setAction","constructorArgsModulePath","process","cwd","error","librariesModulePath","contractAddress","settings","libraryLinks","request","toVerifyRequest","sourceCode","JSON","stringify","compilerVersion","response","verifyContract","pollRequest","toCheckStatusRequest","guid","delay","getVerificationStatus","isVerificationFailure","getMinimumBuild","dependencyGraph","TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH","sourceNames","resolvedFiles","getResolvedFiles","resolvedFile","assertHardhatPluginInvariant","compilationJob","TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE","file","build","TASK_COMPILE_SOLIDITY_COMPILE_JOB","compilationJobs","compilationJobIndex","emitsArtifacts","quiet","inferContract","artifacts","contractMatches","lookupMatchingBytecode","nameList","fqName","_","solidity","compilers","c","overrides","Object","values","push","supportedSolcVersionRange","some","getEtherscanEndpoints","chainConfig","string","isFullyQualifiedName","artifactExists","buildInfo","getBuildInfo","includes","versionDetails","isVersionRange","parseFullyQualifiedName","extractMatchingContractInformation","getLibraryLinks","minimumBuildContractBytecode","output","contracts","evm","object","matchedBytecode","compilerOutput","minimumBuildVerificationStatus","input","task","TASK_VERIFY","addOptionalPositionalParam","addOptionalVariadicPositionalParam","addFlag","invariant","METADATA_ABSENT_VERSION_RANGE","METADATA_PRESENT_SOLC_NOT_FOUND_VERSION_RANGE"],"sources":["/workspace/quanion/node_modules/@nomiclabs/hardhat-etherscan/src/index.ts"],"sourcesContent":["import {\n  TASK_COMPILE,\n  TASK_COMPILE_SOLIDITY_COMPILE_JOB,\n  TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE,\n  TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH,\n} from \"hardhat/builtin-tasks/task-names\";\nimport { extendConfig, subtask, task, types } from \"hardhat/config\";\nimport {\n  ActionType,\n  Artifacts,\n  CompilationJob,\n  CompilerInput,\n  CompilerOutput,\n  DependencyGraph,\n  Network,\n} from \"hardhat/types\";\nimport {\n  isFullyQualifiedName,\n  parseFullyQualifiedName,\n} from \"hardhat/utils/contract-names\";\nimport path from \"path\";\nimport semver from \"semver\";\n\nimport { encodeArguments } from \"./ABIEncoder\";\nimport { etherscanConfigExtender, verifyAllowedChains } from \"./config\";\nimport {\n  pluginName,\n  TASK_VERIFY,\n  TASK_VERIFY_GET_COMPILER_VERSIONS,\n  TASK_VERIFY_GET_CONSTRUCTOR_ARGUMENTS,\n  TASK_VERIFY_GET_CONTRACT_INFORMATION,\n  TASK_VERIFY_GET_ETHERSCAN_ENDPOINT,\n  TASK_VERIFY_GET_LIBRARIES,\n  TASK_VERIFY_GET_MINIMUM_BUILD,\n  TASK_VERIFY_VERIFY,\n  TASK_VERIFY_VERIFY_MINIMUM_BUILD,\n} from \"./constants\";\nimport {\n  delay,\n  getVerificationStatus,\n  isAlreadyVerified,\n  verifyContract,\n} from \"./etherscan/EtherscanService\";\nimport {\n  toCheckStatusRequest,\n  toVerifyRequest,\n} from \"./etherscan/EtherscanVerifyContractRequest\";\nimport { chainConfig } from \"./ChainConfig\";\nimport {\n  getEtherscanEndpoints,\n  retrieveContractBytecode,\n} from \"./network/prober\";\nimport { resolveEtherscanApiKey } from \"./resolveEtherscanApiKey\";\nimport {\n  Bytecode,\n  ContractInformation,\n  extractMatchingContractInformation,\n  lookupMatchingBytecode,\n} from \"./solc/bytecode\";\nimport { getLibraryLinks, Libraries, LibraryNames } from \"./solc/libraries\";\nimport {\n  METADATA_ABSENT_VERSION_RANGE,\n  METADATA_PRESENT_SOLC_NOT_FOUND_VERSION_RANGE,\n} from \"./solc/metadata\";\nimport { getLongVersion } from \"./solc/version\";\nimport \"./type-extensions\";\nimport { EtherscanNetworkEntry, EtherscanURLs } from \"./types\";\nimport { buildContractUrl, printSupportedNetworks } from \"./util\";\nimport { HardhatEtherscanPluginError } from \"./errors\";\n\ninterface VerificationArgs {\n  address?: string;\n  // constructor args given as positional params\n  constructorArgsParams: string[];\n  // Filename of constructor arguments module\n  constructorArgs?: string;\n  // Fully qualified name of the contract\n  contract?: string;\n  // Filename of libraries module\n  libraries?: string;\n\n  // --list-networks flag\n  listNetworks: boolean;\n  // --no-compile flag\n  noCompile: boolean;\n}\n\ninterface VerificationSubtaskArgs {\n  address: string;\n  constructorArguments: any[];\n  // Fully qualified name of the contract\n  contract?: string;\n  libraries: Libraries;\n  noCompile: boolean;\n}\n\ninterface Build {\n  compilationJob: CompilationJob;\n  input: CompilerInput;\n  output: CompilerOutput;\n  solcBuild: any;\n}\n\ninterface MinimumBuildArgs {\n  sourceName: string;\n}\n\ninterface GetContractInformationArgs {\n  contractFQN: string;\n  deployedBytecode: Bytecode;\n  matchingCompilerVersions: string[];\n  libraries: Libraries;\n}\n\ninterface VerifyMinimumBuildArgs {\n  minimumBuild: Build;\n  contractInformation: ContractInformation;\n  etherscanAPIEndpoints: EtherscanURLs;\n  address: string;\n  etherscanAPIKey: string;\n  solcFullVersion: string;\n  deployArgumentsEncoded: string;\n}\n\ninterface LibraryInformation {\n  undetectableLibraries: LibraryNames;\n}\n\ntype ExtendedContractInformation = ContractInformation & LibraryInformation;\n\nextendConfig(etherscanConfigExtender);\n\nconst verify: ActionType<VerificationArgs> = async (\n  {\n    address,\n    constructorArgsParams,\n    constructorArgs: constructorArgsModule,\n    contract,\n    libraries: librariesModule,\n    listNetworks,\n    noCompile,\n  },\n  { config, run }\n) => {\n  if (listNetworks) {\n    await printSupportedNetworks(config.etherscan.customChains);\n    return;\n  }\n\n  if (address === undefined) {\n    throw new HardhatEtherscanPluginError(\n      pluginName,\n      \"You didn’t provide any address. Please re-run the 'verify' task with the address of the contract you want to verify.\"\n    );\n  }\n\n  verifyAllowedChains(config.etherscan);\n\n  const constructorArguments: any[] = await run(\n    TASK_VERIFY_GET_CONSTRUCTOR_ARGUMENTS,\n    {\n      constructorArgsModule,\n      constructorArgsParams,\n    }\n  );\n\n  const libraries: Libraries = await run(TASK_VERIFY_GET_LIBRARIES, {\n    librariesModule,\n  });\n\n  return run(TASK_VERIFY_VERIFY, {\n    address,\n    constructorArguments,\n    contract,\n    libraries,\n    noCompile,\n  });\n};\n\nconst verifySubtask: ActionType<VerificationSubtaskArgs> = async (\n  {\n    address,\n    constructorArguments,\n    contract: contractFQN,\n    libraries,\n    noCompile,\n  },\n  { config, network, run }\n) => {\n  const { etherscan } = config;\n\n  const { isAddress } = await import(\"@ethersproject/address\");\n  if (!isAddress(address)) {\n    throw new HardhatEtherscanPluginError(\n      pluginName,\n      `${address} is an invalid address.`\n    );\n  }\n\n  // This can only happen if the subtask is invoked from within Hardhat by a user script or another task.\n  if (!Array.isArray(constructorArguments)) {\n    throw new HardhatEtherscanPluginError(\n      pluginName,\n      `The constructorArguments parameter should be an array.\nIf your constructor has no arguments pass an empty array. E.g:\n\n  await run(\"${TASK_VERIFY_VERIFY}\", {\n    <other args>,\n    constructorArguments: []\n  };`\n    );\n  }\n\n  const compilerVersions: string[] = await run(\n    TASK_VERIFY_GET_COMPILER_VERSIONS\n  );\n\n  const {\n    network: verificationNetwork,\n    urls: etherscanAPIEndpoints,\n  }: EtherscanNetworkEntry = await run(TASK_VERIFY_GET_ETHERSCAN_ENDPOINT);\n\n  const etherscanAPIKey = resolveEtherscanApiKey(\n    etherscan.apiKey,\n    verificationNetwork\n  );\n\n  const alreadyVerified = await isAlreadyVerified(\n    etherscanAPIEndpoints.apiURL,\n    etherscanAPIKey,\n    address\n  );\n\n  if (alreadyVerified) {\n    console.log(`The contract ${address} has already been verified`);\n    return;\n  }\n\n  const deployedBytecodeHex = await retrieveContractBytecode(\n    address,\n    network.provider,\n    network.name\n  );\n\n  const deployedBytecode = new Bytecode(deployedBytecodeHex);\n  const inferredSolcVersion = deployedBytecode.getInferredSolcVersion();\n\n  const matchingCompilerVersions = compilerVersions.filter((version) => {\n    return semver.satisfies(version, inferredSolcVersion);\n  });\n  if (\n    matchingCompilerVersions.length === 0 &&\n    // don't error if the bytecode appears to be OVM bytecode, because we can't infer a specific OVM solc version from the bytecode\n    !deployedBytecode.isOvmInferred()\n  ) {\n    let configuredCompilersFragment;\n    if (compilerVersions.length > 1) {\n      configuredCompilersFragment = `your configured compiler versions are: ${compilerVersions.join(\n        \", \"\n      )}`;\n    } else {\n      configuredCompilersFragment = `your configured compiler version is: ${compilerVersions[0]}`;\n    }\n    const message = `The contract you want to verify was compiled with solidity ${inferredSolcVersion}, but ${configuredCompilersFragment}.\n\nPossible causes are:\n  - You are not in the same commit that was used to deploy the contract.\n  - Wrong compiler version selected in hardhat config.\n  - The given address is wrong.\n  - The selected network (${network.name}) is wrong.`;\n    throw new HardhatEtherscanPluginError(pluginName, message);\n  }\n\n  // Make sure that contract artifacts are up-to-date.\n  if (!noCompile) {\n    await run(TASK_COMPILE);\n  }\n\n  const contractInformation: ExtendedContractInformation = await run(\n    TASK_VERIFY_GET_CONTRACT_INFORMATION,\n    {\n      contractFQN,\n      deployedBytecode,\n      matchingCompilerVersions,\n      libraries,\n    }\n  );\n\n  // Override solc version based on hardhat config if verifying for the OVM. This is used instead of fetching the\n  // full version name from a solc bin JSON file (as is done for EVM solc in src/solc/version.ts) because it's\n  // simpler and avoids a network request we don't need. This is ok because the solc version specified in the OVM\n  // config always equals the full solc version\n  if (deployedBytecode.isOvmInferred()) {\n    // We cast to this custom type here instead of using `extendConfig` to avoid always mutating the HardhatConfig\n    // type. We don't want that type to always contain the `ovm` field, because users only using hardhat-etherscan\n    // without the Optimism plugin should not have that field in their type definitions\n    const configCopy = { ...config } as unknown as {\n      ovm?: { solcVersion?: string };\n    };\n    const ovmSolcVersion = configCopy.ovm?.solcVersion;\n    if (ovmSolcVersion === undefined) {\n      const message = `It looks like you are verifying an OVM contract, but do not have an OVM solcVersion specified in the hardhat config.`;\n      throw new HardhatEtherscanPluginError(pluginName, message);\n    }\n    contractInformation.solcVersion = `v${ovmSolcVersion}`; // Etherscan requires the leading `v` before the version string\n  }\n\n  const deployArgumentsEncoded = await encodeArguments(\n    contractInformation.contract.abi,\n    contractInformation.sourceName,\n    contractInformation.contractName,\n    constructorArguments\n  );\n\n  // If OVM, the full version string was already read from the hardhat config. If solc, get the full version string\n  const solcFullVersion = deployedBytecode.isOvmInferred()\n    ? contractInformation.solcVersion\n    : await getLongVersion(contractInformation.solcVersion);\n\n  const minimumBuild: Build = await run(TASK_VERIFY_GET_MINIMUM_BUILD, {\n    sourceName: contractInformation.sourceName,\n  });\n\n  const success: boolean = await run(TASK_VERIFY_VERIFY_MINIMUM_BUILD, {\n    minimumBuild,\n    contractInformation,\n    etherscanAPIEndpoints,\n    address,\n    etherscanAPIKey,\n    solcFullVersion,\n    deployArgumentsEncoded,\n  });\n\n  if (success) {\n    return;\n  }\n\n  // Fallback verification\n  const verificationStatus = await attemptVerification(\n    etherscanAPIEndpoints,\n    contractInformation,\n    address,\n    etherscanAPIKey,\n    contractInformation.compilerInput,\n    solcFullVersion,\n    deployArgumentsEncoded\n  );\n\n  if (verificationStatus.isVerificationSuccess()) {\n    const contractURL = buildContractUrl(\n      etherscanAPIEndpoints.browserURL,\n      address\n    );\n\n    console.log(\n      `Successfully verified full build of contract ${contractInformation.contractName} on Etherscan.\n${contractURL}`\n    );\n    return;\n  }\n\n  let errorMessage = `The contract verification failed.\nReason: ${verificationStatus.message}`;\n  if (contractInformation.undetectableLibraries.length > 0) {\n    const undetectableLibraryNames = contractInformation.undetectableLibraries\n      .map(({ sourceName, libName }) => `${sourceName}:${libName}`)\n      .map((x) => `  * ${x}`)\n      .join(\"\\n\");\n    errorMessage += `\nThis contract makes use of libraries whose addresses are undetectable by the plugin.\nKeep in mind that this verification failure may be due to passing in the wrong\naddress for one of these libraries:\n${undetectableLibraryNames}`;\n  }\n  throw new HardhatEtherscanPluginError(pluginName, errorMessage);\n};\n\nsubtask(TASK_VERIFY_GET_CONSTRUCTOR_ARGUMENTS)\n  .addParam(\"constructorArgsParams\", undefined, undefined, types.any)\n  .addOptionalParam(\n    \"constructorArgsModule\",\n    undefined,\n    undefined,\n    types.inputFile\n  )\n  .setAction(\n    async ({\n      constructorArgsModule,\n      constructorArgsParams,\n    }: {\n      constructorArgsModule?: string;\n      constructorArgsParams: string[];\n    }) => {\n      if (typeof constructorArgsModule !== \"string\") {\n        return constructorArgsParams;\n      }\n\n      const constructorArgsModulePath = path.resolve(\n        process.cwd(),\n        constructorArgsModule\n      );\n\n      try {\n        const constructorArguments = (await import(constructorArgsModulePath))\n          .default;\n\n        if (!Array.isArray(constructorArguments)) {\n          throw new HardhatEtherscanPluginError(\n            pluginName,\n            `The module ${constructorArgsModulePath} doesn't export a list. The module should look like this:\n\n  module.exports = [ arg1, arg2, ... ];`\n          );\n        }\n\n        return constructorArguments;\n      } catch (error: any) {\n        throw new HardhatEtherscanPluginError(\n          pluginName,\n          `Importing the module for the constructor arguments list failed.\nReason: ${error.message}`,\n          error\n        );\n      }\n    }\n  );\n\nsubtask(TASK_VERIFY_GET_LIBRARIES)\n  .addOptionalParam(\"librariesModule\", undefined, undefined, types.inputFile)\n  .setAction(\n    async ({\n      librariesModule,\n    }: {\n      librariesModule?: string;\n    }): Promise<Libraries> => {\n      if (typeof librariesModule !== \"string\") {\n        return {};\n      }\n\n      const librariesModulePath = path.resolve(process.cwd(), librariesModule);\n\n      try {\n        const libraries = (await import(librariesModulePath)).default;\n\n        if (typeof libraries !== \"object\" || Array.isArray(libraries)) {\n          throw new HardhatEtherscanPluginError(\n            pluginName,\n            `The module ${librariesModulePath} doesn't export a dictionary. The module should look like this:\n\n  module.exports = { lib1: \"0x...\", lib2: \"0x...\", ... };`\n          );\n        }\n\n        return libraries;\n      } catch (error: any) {\n        throw new HardhatEtherscanPluginError(\n          pluginName,\n          `Importing the module for the libraries dictionary failed.\nReason: ${error.message}`,\n          error\n        );\n      }\n    }\n  );\n\nasync function attemptVerification(\n  etherscanAPIEndpoints: EtherscanURLs,\n  contractInformation: ContractInformation,\n  contractAddress: string,\n  etherscanAPIKey: string,\n  compilerInput: CompilerInput,\n  solcFullVersion: string,\n  deployArgumentsEncoded: string\n) {\n  // Ensure the linking information is present in the compiler input;\n  compilerInput.settings.libraries = contractInformation.libraryLinks;\n  const request = toVerifyRequest({\n    apiKey: etherscanAPIKey,\n    contractAddress,\n    sourceCode: JSON.stringify(compilerInput),\n    sourceName: contractInformation.sourceName,\n    contractName: contractInformation.contractName,\n    compilerVersion: solcFullVersion,\n    constructorArguments: deployArgumentsEncoded,\n  });\n\n  const response = await verifyContract(etherscanAPIEndpoints.apiURL, request);\n\n  console.log(\n    `Successfully submitted source code for contract\n${contractInformation.sourceName}:${contractInformation.contractName} at ${contractAddress}\nfor verification on the block explorer. Waiting for verification result...\n`\n  );\n\n  const pollRequest = toCheckStatusRequest({\n    apiKey: etherscanAPIKey,\n    guid: response.message,\n  });\n\n  // Compilation is bound to take some time so there's no sense in requesting status immediately.\n  await delay(700);\n  const verificationStatus = await getVerificationStatus(\n    etherscanAPIEndpoints.apiURL,\n    pollRequest\n  );\n\n  if (\n    verificationStatus.isVerificationFailure() ||\n    verificationStatus.isVerificationSuccess()\n  ) {\n    return verificationStatus;\n  }\n\n  // Reaching this point shouldn't be possible unless the API is behaving in a new way.\n  throw new HardhatEtherscanPluginError(\n    pluginName,\n    `The API responded with an unexpected message.\nContract verification may have succeeded and should be checked manually.\nMessage: ${verificationStatus.message}`,\n    undefined,\n    true\n  );\n}\n\nconst getMinimumBuild: ActionType<MinimumBuildArgs> = async function (\n  { sourceName },\n  { run }\n): Promise<Build> {\n  const dependencyGraph: DependencyGraph = await run(\n    TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH,\n    { sourceNames: [sourceName] }\n  );\n\n  const resolvedFiles = dependencyGraph\n    .getResolvedFiles()\n    .filter((resolvedFile) => {\n      return resolvedFile.sourceName === sourceName;\n    });\n  assertHardhatPluginInvariant(\n    resolvedFiles.length === 1,\n    `The plugin found an unexpected number of files for this contract.`\n  );\n\n  const compilationJob: CompilationJob = await run(\n    TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE,\n    {\n      dependencyGraph,\n      file: resolvedFiles[0],\n    }\n  );\n\n  const build: Build = await run(TASK_COMPILE_SOLIDITY_COMPILE_JOB, {\n    compilationJob,\n    compilationJobs: [compilationJob],\n    compilationJobIndex: 0,\n    emitsArtifacts: false,\n    quiet: true,\n  });\n\n  return build;\n};\n\nasync function inferContract(\n  artifacts: Artifacts,\n  network: Network,\n  matchingCompilerVersions: string[],\n  deployedBytecode: Bytecode\n) {\n  const contractMatches = await lookupMatchingBytecode(\n    artifacts,\n    matchingCompilerVersions,\n    deployedBytecode\n  );\n  if (contractMatches.length === 0) {\n    const message = `The address provided as argument contains a contract, but its bytecode doesn't match any of your local contracts.\n\nPossible causes are:\n  - Contract code changed after the deployment was executed. This includes code for seemingly unrelated contracts.\n  - A solidity file was added, moved, deleted or renamed after the deployment was executed. This includes files for seemingly unrelated contracts.\n  - Solidity compiler settings were modified after the deployment was executed (like the optimizer, target EVM, etc.).\n  - The given address is wrong.\n  - The selected network (${network.name}) is wrong.`;\n    throw new HardhatEtherscanPluginError(pluginName, message);\n  }\n  if (contractMatches.length > 1) {\n    const nameList = contractMatches\n      .map((contract) => {\n        return `${contract.sourceName}:${contract.contractName}`;\n      })\n      .map((fqName) => `  * ${fqName}`)\n      .join(\"\\n\");\n    const message = `More than one contract was found to match the deployed bytecode.\nPlease use the contract parameter with one of the following contracts:\n${nameList}\n\nFor example:\n\n  hardhat verify --contract contracts/Example.sol:ExampleContract <other args>\n\nIf you are running the verify subtask from within Hardhat instead:\n\n  await run(\"${TASK_VERIFY_VERIFY}\", {\n    <other args>,\n    contract: \"contracts/Example.sol:ExampleContract\"\n  };`;\n    throw new HardhatEtherscanPluginError(pluginName, message, undefined, true);\n  }\n  return contractMatches[0];\n}\n\nsubtask(TASK_VERIFY_GET_COMPILER_VERSIONS).setAction(\n  async (_, { config }): Promise<string[]> => {\n    const compilerVersions = config.solidity.compilers.map((c) => c.version);\n    if (config.solidity.overrides !== undefined) {\n      for (const { version } of Object.values(config.solidity.overrides)) {\n        compilerVersions.push(version);\n      }\n    }\n\n    // Etherscan only supports solidity versions higher than or equal to v0.4.11.\n    // See https://etherscan.io/solcversions\n    const supportedSolcVersionRange = \">=0.4.11\";\n    if (\n      compilerVersions.some((version) => {\n        return !semver.satisfies(version, supportedSolcVersionRange);\n      })\n    ) {\n      throw new HardhatEtherscanPluginError(\n        pluginName,\n        `Etherscan only supports compiler versions 0.4.11 and higher.\nSee https://etherscan.io/solcversions for more information.`\n      );\n    }\n\n    return compilerVersions;\n  }\n);\n\nsubtask(TASK_VERIFY_GET_ETHERSCAN_ENDPOINT).setAction(\n  async (_, { config, network }) =>\n    getEtherscanEndpoints(\n      network.provider,\n      network.name,\n      chainConfig,\n      config.etherscan.customChains\n    )\n);\n\nsubtask(TASK_VERIFY_GET_CONTRACT_INFORMATION)\n  .addParam(\"deployedBytecode\", undefined, undefined, types.any)\n  .addParam(\"matchingCompilerVersions\", undefined, undefined, types.any)\n  .addParam(\"libraries\", undefined, undefined, types.any)\n  .addOptionalParam(\"contractFQN\", undefined, undefined, types.string)\n  .setAction(\n    async (\n      {\n        contractFQN,\n        deployedBytecode,\n        matchingCompilerVersions,\n        libraries,\n      }: GetContractInformationArgs,\n      { network, artifacts }\n    ): Promise<ExtendedContractInformation> => {\n      let contractInformation;\n      if (contractFQN !== undefined) {\n        // Check this particular contract\n        if (!isFullyQualifiedName(contractFQN)) {\n          throw new HardhatEtherscanPluginError(\n            pluginName,\n            `A valid fully qualified name was expected. Fully qualified names look like this: \"contracts/AContract.sol:TheContract\"\nInstead, this name was received: ${contractFQN}`\n          );\n        }\n\n        if (!(await artifacts.artifactExists(contractFQN))) {\n          throw new HardhatEtherscanPluginError(\n            pluginName,\n            `The contract ${contractFQN} is not present in your project.`\n          );\n        }\n\n        // Process BuildInfo here to check version and throw an error if unexpected version is found.\n        const buildInfo = await artifacts.getBuildInfo(contractFQN);\n\n        if (buildInfo === undefined) {\n          throw new HardhatEtherscanPluginError(\n            pluginName,\n            `The contract ${contractFQN} is present in your project, but we couldn't find its sources.\nPlease make sure that it has been compiled by Hardhat and that it is written in Solidity.`\n          );\n        }\n\n        if (\n          !matchingCompilerVersions.includes(buildInfo.solcVersion) &&\n          !deployedBytecode.isOvmInferred()\n        ) {\n          const inferredSolcVersion = deployedBytecode.getInferredSolcVersion();\n          let versionDetails;\n          if (isVersionRange(inferredSolcVersion)) {\n            versionDetails = `a solidity version in the range ${inferredSolcVersion}`;\n          } else {\n            versionDetails = `the solidity version ${inferredSolcVersion}`;\n          }\n\n          throw new HardhatEtherscanPluginError(\n            pluginName,\n            `The contract ${contractFQN} is being compiled with ${buildInfo.solcVersion}.\nHowever, the contract found in the address provided as argument has its bytecode marked with ${versionDetails}.\n\nPossible causes are:\n  - Solidity compiler version settings were modified after the deployment was executed.\n  - The given address is wrong.\n  - The selected network (${network.name}) is wrong.`\n          );\n        }\n\n        const { sourceName, contractName } =\n          parseFullyQualifiedName(contractFQN);\n        contractInformation = await extractMatchingContractInformation(\n          sourceName,\n          contractName,\n          buildInfo,\n          deployedBytecode\n        );\n\n        if (contractInformation === null) {\n          throw new HardhatEtherscanPluginError(\n            pluginName,\n            `The address provided as argument contains a contract, but its bytecode doesn't match the contract ${contractFQN}.\n\nPossible causes are:\n  - Contract code changed after the deployment was executed. This includes code for seemingly unrelated contracts.\n  - A solidity file was added, moved, deleted or renamed after the deployment was executed. This includes files for seemingly unrelated contracts.\n  - Solidity compiler settings were modified after the deployment was executed (like the optimizer, target EVM, etc.).\n  - The given address is wrong.\n  - The selected network (${network.name}) is wrong.`\n          );\n        }\n      } else {\n        // Infer the contract\n        contractInformation = await inferContract(\n          artifacts,\n          network,\n          matchingCompilerVersions,\n          deployedBytecode\n        );\n      }\n\n      const { libraryLinks, undetectableLibraries } = await getLibraryLinks(\n        contractInformation,\n        libraries\n      );\n      return {\n        ...contractInformation,\n        libraryLinks,\n        undetectableLibraries,\n      };\n    }\n  );\n\nsubtask(TASK_VERIFY_VERIFY_MINIMUM_BUILD)\n  .addParam(\"minimumBuild\", undefined, undefined, types.any)\n  .addParam(\"contractInformation\", undefined, undefined, types.any)\n  .addParam(\"etherscanAPIEndpoints\", undefined, undefined, types.any)\n  .addParam(\"address\", undefined, undefined, types.string)\n  .addParam(\"etherscanAPIKey\", undefined, undefined, types.string)\n  .addParam(\"solcFullVersion\", undefined, undefined, types.string)\n  .addParam(\"deployArgumentsEncoded\", undefined, undefined, types.string)\n  .setAction(\n    async ({\n      minimumBuild,\n      contractInformation,\n      etherscanAPIEndpoints,\n      address,\n      etherscanAPIKey,\n      solcFullVersion,\n      deployArgumentsEncoded,\n    }: VerifyMinimumBuildArgs): Promise<boolean> => {\n      const minimumBuildContractBytecode =\n        minimumBuild.output.contracts[contractInformation.sourceName][\n          contractInformation.contractName\n        ].evm.deployedBytecode.object;\n\n      const matchedBytecode =\n        contractInformation.compilerOutput.contracts[\n          contractInformation.sourceName\n        ][contractInformation.contractName].evm.deployedBytecode.object;\n\n      if (minimumBuildContractBytecode === matchedBytecode) {\n        const minimumBuildVerificationStatus = await attemptVerification(\n          etherscanAPIEndpoints,\n          contractInformation,\n          address,\n          etherscanAPIKey,\n          minimumBuild.input,\n          solcFullVersion,\n          deployArgumentsEncoded\n        );\n\n        if (minimumBuildVerificationStatus.isVerificationSuccess()) {\n          const contractURL = buildContractUrl(\n            etherscanAPIEndpoints.browserURL,\n            address\n          );\n          console.log(\n            `Successfully verified contract ${contractInformation.contractName} on Etherscan.\n${contractURL}`\n          );\n          return true;\n        }\n\n        console.log(\n          `We tried verifying your contract ${contractInformation.contractName} without including any unrelated one, but it failed.\nTrying again with the full solc input used to compile and deploy it.\nThis means that unrelated contracts may be displayed on Etherscan...\n`\n        );\n      } else {\n        console.log(\n          `Compiling your contract excluding unrelated contracts did not produce identical bytecode.\nTrying again with the full solc input used to compile and deploy it.\nThis means that unrelated contracts may be displayed on Etherscan...\n`\n        );\n      }\n\n      return false;\n    }\n  );\n\nsubtask(TASK_VERIFY_GET_MINIMUM_BUILD)\n  .addParam(\"sourceName\", undefined, undefined, types.string)\n  .setAction(getMinimumBuild);\n\ntask(TASK_VERIFY, \"Verifies contract on Etherscan\")\n  .addOptionalPositionalParam(\n    \"address\",\n    \"Address of the smart contract to verify\"\n  )\n  .addOptionalParam(\n    \"constructorArgs\",\n    \"File path to a javascript module that exports the list of arguments.\",\n    undefined,\n    types.inputFile\n  )\n  .addOptionalParam(\n    \"contract\",\n    \"Fully qualified name of the contract to verify. \" +\n      \"Skips automatic detection of the contract. \" +\n      \"Use if the deployed bytecode matches more than one contract in your project.\"\n  )\n  .addOptionalParam(\n    \"libraries\",\n    \"File path to a javascript module that exports the dictionary of library addresses for your contract. \" +\n      \"Use if there are undetectable library addresses in your contract. \" +\n      \"Library addresses are undetectable if they are only used in the constructor for your contract.\",\n    undefined,\n    types.inputFile\n  )\n  .addOptionalVariadicPositionalParam(\n    \"constructorArgsParams\",\n    \"Contract constructor arguments. Ignored if the --constructor-args option is used.\",\n    []\n  )\n  .addFlag(\"listNetworks\", \"Print the list of supported networks\")\n  .addFlag(\"noCompile\", \"Don't compile before running this task\")\n  .setAction(verify);\n\nsubtask(TASK_VERIFY_VERIFY)\n  .addParam(\"address\", undefined, undefined, types.string)\n  .addOptionalParam(\"constructorArguments\", undefined, [], types.any)\n  .addOptionalParam(\"contract\", undefined, undefined, types.string)\n  .addOptionalParam(\"libraries\", undefined, {}, types.any)\n  .addFlag(\"noCompile\", undefined)\n  .setAction(verifySubtask);\n\nfunction assertHardhatPluginInvariant(\n  invariant: boolean,\n  message: string\n): asserts invariant {\n  if (!invariant) {\n    throw new HardhatEtherscanPluginError(pluginName, message, undefined, true);\n  }\n}\n\nfunction isVersionRange(version: string): boolean {\n  return (\n    version === METADATA_ABSENT_VERSION_RANGE ||\n    version === METADATA_PRESENT_SOLC_NOT_FOUND_VERSION_RANGE\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}