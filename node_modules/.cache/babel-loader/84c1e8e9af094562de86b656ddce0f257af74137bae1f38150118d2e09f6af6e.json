{"ast":null,"code":"\"use strict\";\n\nimport { arrayify, concat, hexDataLength, hexDataSlice, isHexString, hexStripZeros, hexZeroPad } from \"@quais/bytes\";\nimport { BigNumber, _base16To36, _base36To16 } from \"@quais/bignumber\";\nimport { keccak256 } from \"@quais/keccak256\";\nimport { Logger } from \"@quais/logger\";\nimport { version } from \"./_version\";\nimport { ShardData } from \"@quais/constants\";\nconst logger = new Logger(version);\nfunction getChecksumAddress(address) {\n  if (!isHexString(address, 20)) {\n    logger.throwArgumentError(\"invalid address\", \"address\", address);\n  }\n  address = address.toLowerCase();\n  const chars = address.substring(2).split(\"\");\n  const expanded = new Uint8Array(40);\n  for (let i = 0; i < 40; i++) {\n    expanded[i] = chars[i].charCodeAt(0);\n  }\n  const hashed = arrayify(keccak256(expanded));\n  for (let i = 0; i < 40; i += 2) {\n    if (hashed[i >> 1] >> 4 >= 8) {\n      chars[i] = chars[i].toUpperCase();\n    }\n    if ((hashed[i >> 1] & 0x0f) >= 8) {\n      chars[i + 1] = chars[i + 1].toUpperCase();\n    }\n  }\n  return \"0x\" + chars.join(\"\");\n}\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER = 0x1fffffffffffff;\nfunction log10(x) {\n  if (Math.log10) {\n    return Math.log10(x);\n  }\n  return Math.log(x) / Math.LN10;\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor (let i = 0; i < 10; i++) {\n  ibanLookup[String(i)] = String(i);\n}\nfor (let i = 0; i < 26; i++) {\n  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\nfunction ibanChecksum(address) {\n  address = address.toUpperCase();\n  address = address.substring(4) + address.substring(0, 2) + \"00\";\n  let expanded = address.split(\"\").map(c => {\n    return ibanLookup[c];\n  }).join(\"\");\n  // Javascript can handle integers safely up to 15 (decimal) digits\n  while (expanded.length >= safeDigits) {\n    let block = expanded.substring(0, safeDigits);\n    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n  }\n  let checksum = String(98 - parseInt(expanded, 10) % 97);\n  while (checksum.length < 2) {\n    checksum = \"0\" + checksum;\n  }\n  return checksum;\n}\n;\nexport function getAddress(address) {\n  let result = null;\n  if (typeof address !== \"string\") {\n    logger.throwArgumentError(\"invalid address\", \"address\", address);\n  }\n  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n    // Missing the 0x prefix\n    if (address.substring(0, 2) !== \"0x\") {\n      address = \"0x\" + address;\n    }\n    result = getChecksumAddress(address);\n    // It is a checksummed address with a bad checksum\n    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n      logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n    }\n    // Maybe ICAP? (we only support direct mode)\n  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n    // It is an ICAP address with a bad checksum\n    if (address.substring(2, 4) !== ibanChecksum(address)) {\n      logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n    }\n    result = _base36To16(address.substring(4));\n    while (result.length < 40) {\n      result = \"0\" + result;\n    }\n    result = getChecksumAddress(\"0x\" + result);\n  } else {\n    logger.throwArgumentError(\"invalid address\", \"address\", address);\n  }\n  return result;\n}\nexport function isAddress(address) {\n  try {\n    getAddress(address);\n    return true;\n  } catch (error) {}\n  return false;\n}\nexport function getIcapAddress(address) {\n  let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n  while (base36.length < 30) {\n    base36 = \"0\" + base36;\n  }\n  return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\nexport function getContractAddress(from, nonce, data) {\n  const nonceBytes = hexZeroPad(BigNumber.from(nonce).toHexString(), 8);\n  return getAddress(hexDataSlice(keccak256(concat([getAddress(from), nonceBytes, hexStripZeros(data)])), 12));\n}\nexport function getCreate2Address(from, salt, initCodeHash) {\n  if (hexDataLength(salt) !== 32) {\n    logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n  }\n  if (hexDataLength(initCodeHash) !== 32) {\n    logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n  }\n  return getAddress(hexDataSlice(keccak256(concat([\"0xff\", getAddress(from), salt, initCodeHash])), 12));\n}\nexport function validShard(shard) {\n  let shardData = ShardData.filter(obj => {\n    return obj.shard == shard;\n  });\n  if (shardData.length === 0) {\n    return false;\n  }\n  return true;\n}\nexport function getShardFromAddress(address) {\n  let shardData = ShardData.filter(obj => {\n    const num = Number(address.substring(0, 4));\n    const start = Number(\"0x\" + obj.byte[0]);\n    const end = Number(\"0x\" + obj.byte[1]);\n    return num >= start && num <= end;\n  });\n  if (shardData.length === 0) {\n    return null;\n  }\n  return shardData[0].shard;\n}","map":{"version":3,"names":["arrayify","concat","hexDataLength","hexDataSlice","isHexString","hexStripZeros","hexZeroPad","BigNumber","_base16To36","_base36To16","keccak256","Logger","version","ShardData","logger","getChecksumAddress","address","throwArgumentError","toLowerCase","chars","substring","split","expanded","Uint8Array","i","charCodeAt","hashed","toUpperCase","join","MAX_SAFE_INTEGER","log10","x","Math","log","LN10","ibanLookup","String","fromCharCode","safeDigits","floor","ibanChecksum","map","c","length","block","parseInt","checksum","getAddress","result","match","isAddress","error","getIcapAddress","base36","getContractAddress","from","nonce","data","nonceBytes","toHexString","getCreate2Address","salt","initCodeHash","validShard","shard","shardData","filter","obj","getShardFromAddress","num","Number","start","byte","end"],"sources":["/workspace/quanion/node_modules/@quais/address/src.ts/index.ts"],"sourcesContent":["\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, hexStripZeros, hexZeroPad } from \"@quais/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@quais/bignumber\";\nimport { keccak256 } from \"@quais/keccak256\";\n\nimport { Logger } from \"@quais/logger\";\nimport { version } from \"./_version\";\nimport { ShardData } from \"@quais/constants\";\n\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\nexport function getContractAddress(from: string, nonce: BigNumberish, data: BytesLike): string {\n    const nonceBytes = hexZeroPad(BigNumber.from(nonce).toHexString(), 8);\n    return getAddress(hexDataSlice(keccak256(concat([getAddress(from), nonceBytes, hexStripZeros(data) ])), 12))\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n\nexport function validShard(shard: string) {\n    let shardData = ShardData.filter((obj:any) => {\n        return obj.shard == shard\n    })\n    if (shardData.length === 0) {\n        return false\n    }\n    return true\n}\n\nexport function getShardFromAddress(address: string) {\n    let shardData = ShardData.filter((obj:any) => {\n        const num = Number(address.substring(0, 4))\n        const start = Number(\"0x\" + obj.byte[0])\n        const end = Number(\"0x\" + obj.byte[1])\n        return num >= start && num <= end\n    })\n    if (shardData.length === 0) {\n        return null\n    }\n    return shardData[0].shard\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}