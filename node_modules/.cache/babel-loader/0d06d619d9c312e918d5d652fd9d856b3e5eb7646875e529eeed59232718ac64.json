{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isAlreadyVerified = exports.EtherscanResponse = exports.getVerificationStatus = exports.verifyContract = exports.delay = void 0;\nconst constants_1 = require(\"../constants\");\nconst undici_1 = require(\"../undici\");\nconst errors_1 = require(\"../errors\");\nasync function delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\nexports.delay = delay;\n// Used for polling the result of the contract verification.\nconst verificationIntervalMs = 3000;\nasync function verifyContract(url, req) {\n  const parameters = new URLSearchParams({\n    ...req\n  });\n  let response;\n  try {\n    response = await (0, undici_1.sendPostRequest)(new URL(url), parameters.toString());\n  } catch (error) {\n    throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `Failed to send contract verification request.\nEndpoint URL: ${url}\nReason: ${error.message}`, error);\n  }\n  if (!(response.statusCode >= 200 && response.statusCode <= 299)) {\n    // This could be always interpreted as JSON if there were any such guarantee in the Etherscan API.\n    const responseText = await response.body.text();\n    throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `Failed to send contract verification request.\nEndpoint URL: ${url}\nThe HTTP server response is not ok. Status code: ${response.statusCode} Response text: ${responseText}`);\n  }\n  const etherscanResponse = new EtherscanResponse(await response.body.json());\n  if (etherscanResponse.isBytecodeMissingInNetworkError()) {\n    throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `Failed to send contract verification request.\nEndpoint URL: ${url}\nReason: The Etherscan API responded that the address ${req.contractaddress} does not have bytecode.\nThis can happen if the contract was recently deployed and this fact hasn't propagated to the backend yet.\nTry waiting for a minute before verifying your contract. If you are invoking this from a script,\ntry to wait for five confirmations of your contract deployment transaction before running the verification subtask.`);\n  }\n  if (!etherscanResponse.isOk()) {\n    throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, etherscanResponse.message);\n  }\n  return etherscanResponse;\n}\nexports.verifyContract = verifyContract;\nasync function getVerificationStatus(url, req) {\n  const parameters = new URLSearchParams({\n    ...req\n  });\n  const urlWithQuery = new URL(url);\n  urlWithQuery.search = parameters.toString();\n  let response;\n  try {\n    response = await (0, undici_1.sendGetRequest)(urlWithQuery);\n    if (!(response.statusCode >= 200 && response.statusCode <= 299)) {\n      // This could be always interpreted as JSON if there were any such guarantee in the Etherscan API.\n      const responseText = await response.body.text();\n      const message = `The HTTP server response is not ok. Status code: ${response.statusCode} Response text: ${responseText}`;\n      throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, message);\n    }\n  } catch (error) {\n    throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `Failure during etherscan status polling. The verification may still succeed but\nshould be checked manually.\nEndpoint URL: ${urlWithQuery.toString()}\nReason: ${error.message}`, error);\n  }\n  const etherscanResponse = new EtherscanResponse(await response.body.json());\n  if (etherscanResponse.isPending()) {\n    await delay(verificationIntervalMs);\n    return getVerificationStatus(url, req);\n  }\n  if (etherscanResponse.isVerificationFailure()) {\n    return etherscanResponse;\n  }\n  if (!etherscanResponse.isOk()) {\n    throw new errors_1.HardhatEtherscanPluginError(constants_1.pluginName, `The Etherscan API responded with a failure status.\nThe verification may still succeed but should be checked manually.\nReason: ${etherscanResponse.message}`);\n  }\n  return etherscanResponse;\n}\nexports.getVerificationStatus = getVerificationStatus;\nclass EtherscanResponse {\n  constructor(response) {\n    this.status = parseInt(response.status, 10);\n    this.message = response.result;\n  }\n  isPending() {\n    return this.message === \"Pending in queue\";\n  }\n  isVerificationFailure() {\n    return this.message === \"Fail - Unable to verify\";\n  }\n  isVerificationSuccess() {\n    return this.message === \"Pass - Verified\";\n  }\n  isBytecodeMissingInNetworkError() {\n    return this.message.startsWith(\"Unable to locate ContractCode at\");\n  }\n  isOk() {\n    return this.status === 1;\n  }\n}\nexports.EtherscanResponse = EtherscanResponse;\nasync function isAlreadyVerified(apiURL, apiKey, address) {\n  const parameters = new URLSearchParams({\n    module: \"contract\",\n    action: \"getsourcecode\",\n    address,\n    apikey: apiKey\n  });\n  const url = new URL(apiURL);\n  url.search = parameters.toString();\n  const response = await (0, undici_1.sendGetRequest)(url);\n  const json = await response.body.json();\n  if (json.message !== \"OK\") {\n    return false;\n  }\n  const sourceCode = json?.result?.[0]?.SourceCode;\n  return sourceCode !== undefined && sourceCode !== \"\";\n}\nexports.isAlreadyVerified = isAlreadyVerified;","map":{"version":3,"names":["constants_1","require","undici_1","errors_1","delay","ms","Promise","resolve","setTimeout","exports","verificationIntervalMs","verifyContract","url","req","parameters","URLSearchParams","response","sendPostRequest","URL","toString","error","HardhatEtherscanPluginError","pluginName","message","statusCode","responseText","body","text","etherscanResponse","EtherscanResponse","json","isBytecodeMissingInNetworkError","contractaddress","isOk","getVerificationStatus","urlWithQuery","search","sendGetRequest","isPending","isVerificationFailure","constructor","status","parseInt","result","isVerificationSuccess","startsWith","isAlreadyVerified","apiURL","apiKey","address","module","action","apikey","sourceCode","SourceCode","undefined"],"sources":["/workspace/quanion/node_modules/@nomiclabs/hardhat-etherscan/src/etherscan/EtherscanService.ts"],"sourcesContent":["import { Dispatcher } from \"undici\";\n\nimport { pluginName } from \"../constants\";\nimport { sendGetRequest, sendPostRequest } from \"../undici\";\n\nimport { HardhatEtherscanPluginError } from \"../errors\";\nimport {\n  EtherscanCheckStatusRequest,\n  EtherscanVerifyRequest,\n} from \"./EtherscanVerifyContractRequest\";\n\nexport async function delay(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n// Used for polling the result of the contract verification.\nconst verificationIntervalMs = 3000;\n\nexport async function verifyContract(\n  url: string,\n  req: EtherscanVerifyRequest\n): Promise<EtherscanResponse> {\n  const parameters = new URLSearchParams({ ...req });\n\n  let response: Dispatcher.ResponseData;\n  try {\n    response = await sendPostRequest(new URL(url), parameters.toString());\n  } catch (error: any) {\n    throw new HardhatEtherscanPluginError(\n      pluginName,\n      `Failed to send contract verification request.\nEndpoint URL: ${url}\nReason: ${error.message}`,\n      error\n    );\n  }\n\n  if (!(response.statusCode >= 200 && response.statusCode <= 299)) {\n    // This could be always interpreted as JSON if there were any such guarantee in the Etherscan API.\n    const responseText = await response.body.text();\n    throw new HardhatEtherscanPluginError(\n      pluginName,\n      `Failed to send contract verification request.\nEndpoint URL: ${url}\nThe HTTP server response is not ok. Status code: ${response.statusCode} Response text: ${responseText}`\n    );\n  }\n\n  const etherscanResponse = new EtherscanResponse(await response.body.json());\n\n  if (etherscanResponse.isBytecodeMissingInNetworkError()) {\n    throw new HardhatEtherscanPluginError(\n      pluginName,\n      `Failed to send contract verification request.\nEndpoint URL: ${url}\nReason: The Etherscan API responded that the address ${req.contractaddress} does not have bytecode.\nThis can happen if the contract was recently deployed and this fact hasn't propagated to the backend yet.\nTry waiting for a minute before verifying your contract. If you are invoking this from a script,\ntry to wait for five confirmations of your contract deployment transaction before running the verification subtask.`\n    );\n  }\n\n  if (!etherscanResponse.isOk()) {\n    throw new HardhatEtherscanPluginError(\n      pluginName,\n      etherscanResponse.message\n    );\n  }\n\n  return etherscanResponse;\n}\n\nexport async function getVerificationStatus(\n  url: string,\n  req: EtherscanCheckStatusRequest\n): Promise<EtherscanResponse> {\n  const parameters = new URLSearchParams({ ...req });\n  const urlWithQuery = new URL(url);\n  urlWithQuery.search = parameters.toString();\n\n  let response;\n  try {\n    response = await sendGetRequest(urlWithQuery);\n\n    if (!(response.statusCode >= 200 && response.statusCode <= 299)) {\n      // This could be always interpreted as JSON if there were any such guarantee in the Etherscan API.\n      const responseText = await response.body.text();\n      const message = `The HTTP server response is not ok. Status code: ${response.statusCode} Response text: ${responseText}`;\n\n      throw new HardhatEtherscanPluginError(pluginName, message);\n    }\n  } catch (error: any) {\n    throw new HardhatEtherscanPluginError(\n      pluginName,\n      `Failure during etherscan status polling. The verification may still succeed but\nshould be checked manually.\nEndpoint URL: ${urlWithQuery.toString()}\nReason: ${error.message}`,\n      error\n    );\n  }\n\n  const etherscanResponse = new EtherscanResponse(await response.body.json());\n\n  if (etherscanResponse.isPending()) {\n    await delay(verificationIntervalMs);\n\n    return getVerificationStatus(url, req);\n  }\n\n  if (etherscanResponse.isVerificationFailure()) {\n    return etherscanResponse;\n  }\n\n  if (!etherscanResponse.isOk()) {\n    throw new HardhatEtherscanPluginError(\n      pluginName,\n      `The Etherscan API responded with a failure status.\nThe verification may still succeed but should be checked manually.\nReason: ${etherscanResponse.message}`\n    );\n  }\n\n  return etherscanResponse;\n}\n\nexport class EtherscanResponse {\n  public readonly status: number;\n\n  public readonly message: string;\n\n  constructor(response: any) {\n    this.status = parseInt(response.status, 10);\n    this.message = response.result;\n  }\n\n  public isPending() {\n    return this.message === \"Pending in queue\";\n  }\n\n  public isVerificationFailure() {\n    return this.message === \"Fail - Unable to verify\";\n  }\n\n  public isVerificationSuccess() {\n    return this.message === \"Pass - Verified\";\n  }\n\n  public isBytecodeMissingInNetworkError() {\n    return this.message.startsWith(\"Unable to locate ContractCode at\");\n  }\n\n  public isOk() {\n    return this.status === 1;\n  }\n}\n\nexport async function isAlreadyVerified(\n  apiURL: string,\n  apiKey: string,\n  address: string\n): Promise<boolean> {\n  const parameters = new URLSearchParams({\n    module: \"contract\",\n    action: \"getsourcecode\",\n    address,\n    apikey: apiKey,\n  });\n\n  const url = new URL(apiURL);\n  url.search = parameters.toString();\n\n  const response = await sendGetRequest(url);\n  const json = await response.body.json();\n\n  if (json.message !== \"OK\") {\n    return false;\n  }\n\n  const sourceCode = json?.result?.[0]?.SourceCode;\n  return sourceCode !== undefined && sourceCode !== \"\";\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}