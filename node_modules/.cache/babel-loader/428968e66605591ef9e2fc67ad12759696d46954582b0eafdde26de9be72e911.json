{"ast":null,"code":"\"use strict\";\n\nimport { getAddress } from \"@quais/address\";\nimport { BigNumber } from \"@quais/bignumber\";\nimport { arrayify, hexConcat, hexDataLength, hexDataSlice, hexlify, hexZeroPad, splitSignature, stripZeros } from \"@quais/bytes\";\nimport { Zero } from \"@quais/constants\";\nimport { keccak256 } from \"@quais/keccak256\";\nimport * as RLP from \"@quais/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@quais/signing-key\";\nimport { Logger } from \"@quais/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport var TransactionTypes;\n(function (TransactionTypes) {\n  TransactionTypes[TransactionTypes[\"standard\"] = 0] = \"standard\";\n  TransactionTypes[TransactionTypes[\"etx\"] = 1] = \"etx\";\n  TransactionTypes[TransactionTypes[\"standardETx\"] = 2] = \"standardETx\";\n})(TransactionTypes || (TransactionTypes = {}));\n;\n///////////////////////////////\nfunction handleAddress(value) {\n  if (value === \"0x\") {\n    return null;\n  }\n  return getAddress(value);\n}\nfunction handleNumber(value) {\n  if (value === \"0x\") {\n    return Zero;\n  }\n  return BigNumber.from(value);\n}\nexport function computeAddress(key) {\n  const publicKey = computePublicKey(key);\n  return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\nexport function recoverAddress(digest, signature) {\n  return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\nfunction formatNumber(value, name) {\n  const result = stripZeros(BigNumber.from(value).toHexString());\n  if (result.length > 32) {\n    logger.throwArgumentError(\"invalid length for \" + name, \"transaction:\" + name, value);\n  }\n  return result;\n}\nfunction accessSetify(addr, storageKeys) {\n  return {\n    address: getAddress(addr),\n    storageKeys: (storageKeys || []).map((storageKey, index) => {\n      if (hexDataLength(storageKey) !== 32) {\n        logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${addr}:${index}]`, storageKey);\n      }\n      return storageKey.toLowerCase();\n    })\n  };\n}\nexport function accessListify(value) {\n  if (Array.isArray(value)) {\n    return value.map((set, index) => {\n      if (Array.isArray(set)) {\n        if (set.length > 2) {\n          logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${index}]`, set);\n        }\n        return accessSetify(set[0], set[1]);\n      }\n      return accessSetify(set.address, set.storageKeys);\n    });\n  }\n  const result = Object.keys(value).map(addr => {\n    const storageKeys = value[addr].reduce((accum, storageKey) => {\n      accum[storageKey] = true;\n      return accum;\n    }, {});\n    return accessSetify(addr, Object.keys(storageKeys).sort());\n  });\n  result.sort((a, b) => a.address.localeCompare(b.address));\n  return result;\n}\nfunction formatAccessList(value) {\n  return accessListify(value).map(set => [set.address, set.storageKeys]);\n}\nfunction _serialize(transaction, signature) {\n  // If there is an explicit gasPrice, make sure it matches the\n  // EIP-1559 fees; otherwise they may not understand what they\n  // think they are setting in terms of fee.\n  if (transaction.gasPrice != null) {\n    const gasPrice = BigNumber.from(transaction.gasPrice);\n    const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\n    if (!gasPrice.eq(maxFeePerGas)) {\n      logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n        gasPrice,\n        maxFeePerGas\n      });\n    }\n  }\n  const fields = [formatNumber(transaction.chainId || 0, \"chainId\"), formatNumber(transaction.nonce || 0, \"nonce\"), formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"), formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"), formatNumber(transaction.gasLimit || 0, \"gasLimit\"), transaction.to != null ? getAddress(transaction.to) : \"0x\", formatNumber(transaction.value || 0, \"value\"), transaction.data || \"0x\", formatAccessList(transaction.accessList || [])];\n  if (signature) {\n    const sig = splitSignature(signature);\n    fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n    fields.push(stripZeros(sig.r));\n    fields.push(stripZeros(sig.s));\n  }\n  return hexConcat([\"0x00\", RLP.encode(fields)]);\n}\nfunction _serializeStandardETx(transaction, signature) {\n  const fields = [formatNumber(transaction.chainId || 0, \"chainId\"), formatNumber(transaction.nonce || 0, \"nonce\"), formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"), formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"), formatNumber(transaction.gasLimit || 0, \"gasLimit\"), transaction.to != null ? getAddress(transaction.to) : \"0x\", formatNumber(transaction.value || 0, \"value\"), transaction.data || \"0x\", formatAccessList(transaction.accessList || []), formatNumber(transaction.externalGasLimit || 0, \"externalGasLimit\"), formatNumber(transaction.externalGasPrice || 0, \"externalGasPrice\"), formatNumber(transaction.externalGasTip || 0, \"externalGasTip\"), transaction.externalData || \"0x\", formatAccessList(transaction.externalAccessList || [])];\n  if (signature) {\n    const sig = splitSignature(signature);\n    fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n    fields.push(stripZeros(sig.r));\n    fields.push(stripZeros(sig.s));\n  }\n  return hexConcat([\"0x02\", RLP.encode(fields)]);\n}\nexport function serialize(transaction, signature) {\n  // Typed Transactions (standard and ETx)\n  switch (transaction.type) {\n    case 0:\n      return _serialize(transaction, signature);\n    case 2:\n      return _serializeStandardETx(transaction, signature);\n    default:\n      break;\n  }\n  return logger.throwError(`unsupported transaction type: ${transaction.type}`, Logger.errors.UNSUPPORTED_OPERATION, {\n    operation: \"serializeTransaction\",\n    transactionType: transaction.type\n  });\n}\nfunction _parseEipSignature(tx, fields, serialize) {\n  try {\n    const recid = handleNumber(fields[0]).toNumber();\n    if (recid !== 0 && recid !== 1) {\n      throw new Error(\"bad recid\");\n    }\n    tx.v = recid;\n  } catch (error) {\n    logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n  }\n  tx.r = hexZeroPad(fields[1], 32);\n  tx.s = hexZeroPad(fields[2], 32);\n  try {\n    const digest = keccak256(serialize(tx));\n    tx.from = recoverAddress(digest, {\n      r: tx.r,\n      s: tx.s,\n      recoveryParam: tx.v\n    });\n  } catch (error) {}\n}\nfunction _parse(payload) {\n  const transaction = RLP.decode(payload.slice(1));\n  if (transaction.length !== 9 && transaction.length !== 12) {\n    logger.throwArgumentError(\"invalid component count for transaction type: 0\", \"payload\", hexlify(payload));\n  }\n  const maxPriorityFeePerGas = handleNumber(transaction[2]);\n  const maxFeePerGas = handleNumber(transaction[3]);\n  const tx = {\n    type: 0,\n    chainId: handleNumber(transaction[0]).toNumber(),\n    nonce: handleNumber(transaction[1]).toNumber(),\n    maxPriorityFeePerGas: maxPriorityFeePerGas,\n    maxFeePerGas: maxFeePerGas,\n    gasPrice: null,\n    gasLimit: handleNumber(transaction[4]),\n    to: handleAddress(transaction[5]),\n    value: handleNumber(transaction[6]),\n    data: transaction[7],\n    accessList: accessListify(transaction[8])\n  };\n  // Unsigned EIP-1559 Transaction\n  if (transaction.length === 9) {\n    return tx;\n  }\n  tx.hash = keccak256(payload);\n  _parseEipSignature(tx, transaction.slice(9), _serialize);\n  return tx;\n}\nfunction _parseStandardETx(payload) {\n  const transaction = RLP.decode(payload.slice(1));\n  if (transaction.length !== 8 && transaction.length !== 17) {\n    logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\n  }\n  const maxPriorityFeePerGas = handleNumber(transaction[2]);\n  const maxFeePerGas = handleNumber(transaction[3]);\n  const tx = {\n    type: 2,\n    chainId: handleNumber(transaction[0]).toNumber(),\n    nonce: handleNumber(transaction[1]).toNumber(),\n    maxPriorityFeePerGas: maxPriorityFeePerGas,\n    maxFeePerGas: maxFeePerGas,\n    gasPrice: null,\n    gasLimit: handleNumber(transaction[4]),\n    to: handleAddress(transaction[5]),\n    value: handleNumber(transaction[6]),\n    data: transaction[7],\n    accessList: accessListify(transaction[8]),\n    externalGasLimit: handleNumber(transaction[9]),\n    externalGasPrice: handleNumber(transaction[10]),\n    externalGasTip: handleNumber(transaction[11]),\n    externalData: transaction[12],\n    externalAccessList: accessListify(transaction[13])\n  };\n  // Unsigned EIP-2930 Transaction\n  if (transaction.length === 8) {\n    return tx;\n  }\n  tx.hash = keccak256(payload);\n  _parseEipSignature(tx, transaction.slice(14), _serializeStandardETx);\n  return tx;\n}\nexport function parse(rawTransaction) {\n  const payload = arrayify(rawTransaction);\n  // Typed Transaction (EIP-2718)\n  switch (payload[0]) {\n    case 0:\n      return _parse(payload);\n    case 2:\n      return _parseStandardETx(payload);\n    default:\n      break;\n  }\n  return logger.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {\n    operation: \"parseTransaction\",\n    transactionType: payload[0]\n  });\n}","map":{"version":3,"names":["getAddress","BigNumber","arrayify","hexConcat","hexDataLength","hexDataSlice","hexlify","hexZeroPad","splitSignature","stripZeros","Zero","keccak256","RLP","computePublicKey","recoverPublicKey","Logger","version","logger","TransactionTypes","handleAddress","value","handleNumber","from","computeAddress","key","publicKey","recoverAddress","digest","signature","formatNumber","name","result","toHexString","length","throwArgumentError","accessSetify","addr","storageKeys","address","map","storageKey","index","toLowerCase","accessListify","Array","isArray","set","Object","keys","reduce","accum","sort","a","b","localeCompare","formatAccessList","_serialize","transaction","gasPrice","maxFeePerGas","eq","fields","chainId","nonce","maxPriorityFeePerGas","gasLimit","to","data","accessList","sig","push","recoveryParam","r","s","encode","_serializeStandardETx","externalGasLimit","externalGasPrice","externalGasTip","externalData","externalAccessList","serialize","type","throwError","errors","UNSUPPORTED_OPERATION","operation","transactionType","_parseEipSignature","tx","recid","toNumber","Error","v","error","_parse","payload","decode","slice","hash","_parseStandardETx","parse","rawTransaction"],"sources":["/workspace/quanion/node_modules/@quais/transactions/src.ts/index.ts"],"sourcesContent":["\"use strict\";\n\nimport { getAddress } from \"@quais/address\";\nimport { BigNumber, BigNumberish } from \"@quais/bignumber\";\nimport { arrayify, BytesLike, hexConcat, hexDataLength, hexDataSlice, hexlify, hexZeroPad, SignatureLike, splitSignature, stripZeros, } from \"@quais/bytes\";\nimport { Zero } from \"@quais/constants\";\nimport { keccak256 } from \"@quais/keccak256\";\nimport * as RLP from \"@quais/rlp\";\nimport { computePublicKey, recoverPublicKey } from \"@quais/signing-key\";\n\nimport { Logger } from \"@quais/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type AccessList = Array<{ address: string, storageKeys: Array<string> }>;\n\n// Input allows flexibility in describing an access list\nexport type AccessListish = AccessList |\n                            Array<[ string, Array<string> ]> |\n                            Record<string, Array<string>>;\n\nexport enum TransactionTypes {\n    standard = 0,\n    etx = 1,\n    standardETx = 2\n};\n\nexport type UnsignedTransaction = {\n    to?: string;\n    nonce?: number;\n\n    gasLimit?: BigNumberish;\n    gasPrice?: BigNumberish;\n\n    data?: BytesLike;\n    value?: BigNumberish;\n    chainId?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 1 & EIP-1559; Type 2\n    accessList?: AccessListish;\n\n    // EIP-1559; Type 2\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n\n    // ETx field; Type 1\n    externalGasLimit?: BigNumber;\n    externalGasPrice?: BigNumber;\n    externalGasTip?: BigNumber;\n    externalData?: string;\n    externalAccessList?: AccessListish;\n}\n\nexport interface Transaction {\n    hash?: string;\n\n    to?: string;\n    from?: string;\n    nonce: number;\n\n    gasLimit: BigNumber;\n    gasPrice?: BigNumber;\n    maxPriorityFeePerGas?: BigNumber;\n    maxFeePerGas?: BigNumber;\n\n    data: string;\n    value: BigNumber;\n    chainId: number;\n\n    r?: string;\n    s?: string;\n    v?: number;\n\n    // Typed-Transaction features\n    type?: number | null;\n\n    // EIP-2930; Type 0 & EIP-1559;\n    accessList?: AccessList;\n\n    // ETx field; Type 1\n    externalGasLimit?: BigNumber;\n    externalGasPrice?: BigNumber;\n    externalGasTip?: BigNumber;\n    externalData?: string;\n    externalAccessList?: AccessList;\n}\n\n///////////////////////////////\n\nfunction handleAddress(value: string): string {\n    if (value === \"0x\") { return null; }\n    return getAddress(value);\n}\n\nfunction handleNumber(value: string): BigNumber {\n    if (value === \"0x\") { return Zero; }\n    return BigNumber.from(value);\n}\n\nexport function computeAddress(key: BytesLike | string): string {\n    const publicKey = computePublicKey(key);\n    return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\n\nexport function recoverAddress(digest: BytesLike, signature: SignatureLike): string {\n    return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\n\nfunction formatNumber(value: BigNumberish, name: string): Uint8Array {\n    const result = stripZeros(BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\n    }\n    return result;\n}\n\nfunction accessSetify(addr: string, storageKeys: Array<string>): { address: string,storageKeys: Array<string> } {\n    return {\n        address: getAddress(addr),\n        storageKeys: (storageKeys || []).map((storageKey, index) => {\n            if (hexDataLength(storageKey) !== 32) {\n                logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${ addr }:${ index }]`, storageKey)\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\n\nexport function accessListify(value: AccessListish): AccessList {\n    if (Array.isArray(value)) {\n        return (<Array<[ string, Array<string>] | { address: string, storageKeys: Array<string>}>>value).map((set, index) => {\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${ index }]`, set);\n                }\n                return accessSetify(set[0], set[1])\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n\n    const result: Array<{ address: string, storageKeys: Array<string> }> = Object.keys(value).map((addr) => {\n        const storageKeys: Record<string, true> = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, <Record<string, true>>{ });\n        return accessSetify(addr, Object.keys(storageKeys).sort())\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\n\nfunction formatAccessList(value: AccessListish): Array<[ string, Array<string> ]> {\n    return accessListify(value).map((set) => [ set.address, set.storageKeys ]);\n}\n\nfunction _serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        const gasPrice = BigNumber.from(transaction.gasPrice);\n        const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice, maxFeePerGas\n            });\n        }\n    }\n\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x00\", RLP.encode(fields)]);\n}\n\n\nfunction _serializeStandardETx(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    const fields: any = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to): \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || [])),\n        formatNumber(transaction.externalGasLimit || 0, \"externalGasLimit\"),\n        formatNumber(transaction.externalGasPrice || 0, \"externalGasPrice\"),\n        formatNumber(transaction.externalGasTip || 0, \"externalGasTip\"),\n        (transaction.externalData || \"0x\"),\n        (formatAccessList(transaction.externalAccessList || [])),\n    ];\n\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n\n    return hexConcat([ \"0x02\", RLP.encode(fields)]);\n}\n\nexport function serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string {\n    // Typed Transactions (standard and ETx)\n    switch (transaction.type) {\n        case 0:\n            return _serialize(transaction, signature);\n        case 2:\n            return _serializeStandardETx(transaction, signature);\n\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ transaction.type }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\n\nfunction _parseEipSignature(tx: Transaction, fields: Array<string>, serialize: (tx: UnsignedTransaction) => string): void {\n    try {\n        const recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) { throw new Error(\"bad recid\"); }\n        tx.v = recid;\n    } catch (error) {\n        logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n\n    tx.r = hexZeroPad(fields[1], 32);\n    tx.s = hexZeroPad(fields[2], 32);\n\n    try {\n        const digest = keccak256(serialize(tx));\n        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\n    } catch (error) { }\n}\n\nfunction _parse(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 0\", \"payload\", hexlify(payload));\n    }\n\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx: Transaction = {\n        type:                  0,\n        chainId:               handleNumber(transaction[0]).toNumber(),\n        nonce:                 handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas:  maxPriorityFeePerGas,\n        maxFeePerGas:          maxFeePerGas,\n        gasPrice:              null,\n        gasLimit:              handleNumber(transaction[4]),\n        to:                    handleAddress(transaction[5]),\n        value:                 handleNumber(transaction[6]),\n        data:                  transaction[7],\n        accessList:            accessListify(transaction[8]),\n    };\n\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) { return tx; }\n\n    tx.hash = keccak256(payload);\n    _parseEipSignature(tx, transaction.slice(9), _serialize);\n\n    return tx;\n}\n\nfunction _parseStandardETx(payload: Uint8Array): Transaction {\n    const transaction = RLP.decode(payload.slice(1));\n\n    if (transaction.length !== 8 && transaction.length !== 17) {\n        logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\n    }\n\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx: Transaction = {\n        type:       2,\n        chainId:    handleNumber(transaction[0]).toNumber(),\n        nonce:      handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas:  maxPriorityFeePerGas,\n        maxFeePerGas:          maxFeePerGas,\n        gasPrice:   null,\n        gasLimit:   handleNumber(transaction[4]),\n        to:         handleAddress(transaction[5]),\n        value:      handleNumber(transaction[6]),\n        data:       transaction[7],\n        accessList: accessListify(transaction[8]),\n        externalGasLimit: handleNumber(transaction[9]),\n        externalGasPrice:  handleNumber(transaction[10]),\n        externalGasTip:  handleNumber(transaction[11]),\n        externalData: transaction[12],\n        externalAccessList: accessListify(transaction[13])\n    };\n\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) { return tx; }\n\n    tx.hash = keccak256(payload);\n    _parseEipSignature(tx, transaction.slice(14), _serializeStandardETx);\n\n    return tx;\n}\n\nexport function parse(rawTransaction: BytesLike): Transaction {\n    const payload = arrayify(rawTransaction);\n\n    // Typed Transaction (EIP-2718)\n    switch (payload[0]) {\n        case 0:\n            return _parse(payload);\n        case 2:\n            return _parseStandardETx(payload);\n        default:\n            break;\n    }\n\n    return logger.throwError(`unsupported transaction type: ${ payload[0] }`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}