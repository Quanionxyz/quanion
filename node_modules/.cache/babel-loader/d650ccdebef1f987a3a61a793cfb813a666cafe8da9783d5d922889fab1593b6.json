{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.measureExecutableSectionLength = exports.getSolcMetadataSectionLength = exports.decodeSolcMetadata = exports.inferSolcVersion = exports.METADATA_ABSENT_VERSION_RANGE = exports.METADATA_PRESENT_SOLC_NOT_FOUND_VERSION_RANGE = exports.METADATA_LENGTH_SIZE = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst util_1 = __importDefault(require(\"util\"));\nconst cbor_1 = require(\"cbor\");\nexports.METADATA_LENGTH_SIZE = 2;\nexports.METADATA_PRESENT_SOLC_NOT_FOUND_VERSION_RANGE = \"0.4.7 - 0.5.8\";\nexports.METADATA_ABSENT_VERSION_RANGE = \"<0.4.7\";\nconst log = (0, debug_1.default)(\"hardhat:hardhat-etherscan:metadata\");\nfunction inferSolcVersion(bytecode) {\n  // We want to provide our best inference here.\n  // We can infer that some solidity compiler releases couldn't have produced this bytecode.\n  // Solc v0.4.7 was the first compiler to introduce metadata into the generated bytecode.\n  // See https://solidity.readthedocs.io/en/v0.4.7/miscellaneous.html#contract-metadata\n  // Solc v0.4.26, the last release for the v0.4 series, does not feature the compiler version in its emitted metadata.\n  // See https://solidity.readthedocs.io/en/v0.4.26/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode\n  // Solc v0.5.9 was the first compiler to introduce its version into the metadata.\n  // See https://solidity.readthedocs.io/en/v0.5.9/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode\n  // Solc v0.6.0 features compiler version metadata.\n  // See https://solidity.readthedocs.io/en/v0.6.0/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode\n  let solcMetadata;\n  let metadataSectionSizeInBytes;\n  try {\n    const metadata = decodeSolcMetadata(bytecode);\n    log(`Metadata decoded: ${util_1.default.inspect(metadata.decoded)}`);\n    metadataSectionSizeInBytes = metadata.metadataSectionSizeInBytes;\n    solcMetadata = metadata.decoded.solc;\n  } catch {\n    // The decoding failed. Unfortunately, our only option is to assume that this bytecode was emitted by an old version.\n    // Technically, this bytecode could have been emitted by a compiler for another language altogether.\n    // TODO: add detection logic for other compilers if they become relevant?\n    log(\"Could not decode metadata.\");\n    return {\n      metadataSectionSizeInBytes: 0,\n      solcVersion: exports.METADATA_ABSENT_VERSION_RANGE\n    };\n  }\n  if (solcMetadata instanceof Buffer) {\n    if (solcMetadata.length === 3) {\n      const [major, minor, patch] = solcMetadata;\n      const solcVersion = `${major}.${minor}.${patch}`;\n      log(`Solc version detected in bytecode: ${solcVersion}`);\n      return {\n        metadataSectionSizeInBytes,\n        solcVersion\n      };\n    }\n    log(`Found solc version field with ${solcMetadata.length} elements instead of three!`);\n  }\n  // The embedded metadata was successfully decoded but there was no solc version in it.\n  log(`Could not detect solidity version in metadata.`);\n  return {\n    metadataSectionSizeInBytes,\n    solcVersion: exports.METADATA_PRESENT_SOLC_NOT_FOUND_VERSION_RANGE\n  };\n}\nexports.inferSolcVersion = inferSolcVersion;\nfunction decodeSolcMetadata(bytecode) {\n  const metadataSectionLength = getSolcMetadataSectionLength(bytecode);\n  // The metadata and its length are in the last few bytes.\n  const metadataPayload = bytecode.slice(-metadataSectionLength, -exports.METADATA_LENGTH_SIZE);\n  log(`Read metadata length ${metadataSectionLength}`);\n  const lastMetadataBytes = metadataPayload.slice(-100);\n  log(`Last ${lastMetadataBytes.length} bytes of metadata: ${lastMetadataBytes.toString(\"hex\")}`);\n  const decoded = (0, cbor_1.decodeFirstSync)(metadataPayload, {\n    required: true\n  });\n  return {\n    decoded,\n    metadataSectionSizeInBytes: metadataSectionLength\n  };\n}\nexports.decodeSolcMetadata = decodeSolcMetadata;\nfunction getSolcMetadataSectionLength(bytecode) {\n  return bytecode.slice(-exports.METADATA_LENGTH_SIZE).readUInt16BE(0) + exports.METADATA_LENGTH_SIZE;\n}\nexports.getSolcMetadataSectionLength = getSolcMetadataSectionLength;\n/**\n * This function helps us measure the size of the executable section\n * without actually decoding the whole bytecode string.\n *\n * This is useful because the runtime object emitted by the compiler\n * may contain nonhexadecimal characters due to link placeholders.\n */\nfunction measureExecutableSectionLength(bytecode) {\n  if (bytecode.startsWith(\"0x\")) {\n    bytecode = bytecode.slice(2);\n  }\n  // `Buffer.from` will return a buffer that contains bytes up until the last decodable byte.\n  // To work around this we'll just slice the relevant part of the bytecode.\n  const metadataLengthSlice = Buffer.from(bytecode.slice(-exports.METADATA_LENGTH_SIZE * 2), \"hex\");\n  // If, for whatever reason, the bytecode is so small that we can't even read two bytes off it,\n  // return the size of the entire bytecode.\n  if (metadataLengthSlice.length !== exports.METADATA_LENGTH_SIZE) {\n    return bytecode.length;\n  }\n  const runtimeMetadataSectionLength = getSolcMetadataSectionLength(metadataLengthSlice);\n  return bytecode.length - runtimeMetadataSectionLength * 2;\n}\nexports.measureExecutableSectionLength = measureExecutableSectionLength;","map":{"version":3,"names":["debug_1","__importDefault","require","util_1","cbor_1","exports","METADATA_LENGTH_SIZE","METADATA_PRESENT_SOLC_NOT_FOUND_VERSION_RANGE","METADATA_ABSENT_VERSION_RANGE","log","default","inferSolcVersion","bytecode","solcMetadata","metadataSectionSizeInBytes","metadata","decodeSolcMetadata","inspect","decoded","solc","solcVersion","Buffer","length","major","minor","patch","metadataSectionLength","getSolcMetadataSectionLength","metadataPayload","slice","lastMetadataBytes","toString","decodeFirstSync","required","readUInt16BE","measureExecutableSectionLength","startsWith","metadataLengthSlice","from","runtimeMetadataSectionLength"],"sources":["/workspace/quanion/node_modules/@nomiclabs/hardhat-etherscan/src/solc/metadata.ts"],"sourcesContent":["import debug from \"debug\";\nimport util from \"util\";\nimport { decodeFirstSync } from \"cbor\";\n\ninterface MetadataDescription {\n  solcVersion: string;\n  metadataSectionSizeInBytes: number;\n}\n\nexport const METADATA_LENGTH_SIZE = 2;\nexport const METADATA_PRESENT_SOLC_NOT_FOUND_VERSION_RANGE = \"0.4.7 - 0.5.8\";\nexport const METADATA_ABSENT_VERSION_RANGE = \"<0.4.7\";\n\nconst log = debug(\"hardhat:hardhat-etherscan:metadata\");\n\nexport function inferSolcVersion(bytecode: Buffer): MetadataDescription {\n  // We want to provide our best inference here.\n  // We can infer that some solidity compiler releases couldn't have produced this bytecode.\n  // Solc v0.4.7 was the first compiler to introduce metadata into the generated bytecode.\n  // See https://solidity.readthedocs.io/en/v0.4.7/miscellaneous.html#contract-metadata\n  // Solc v0.4.26, the last release for the v0.4 series, does not feature the compiler version in its emitted metadata.\n  // See https://solidity.readthedocs.io/en/v0.4.26/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode\n  // Solc v0.5.9 was the first compiler to introduce its version into the metadata.\n  // See https://solidity.readthedocs.io/en/v0.5.9/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode\n  // Solc v0.6.0 features compiler version metadata.\n  // See https://solidity.readthedocs.io/en/v0.6.0/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode\n  let solcMetadata;\n  let metadataSectionSizeInBytes;\n  try {\n    const metadata = decodeSolcMetadata(bytecode);\n    log(`Metadata decoded: ${util.inspect(metadata.decoded)}`);\n    metadataSectionSizeInBytes = metadata.metadataSectionSizeInBytes;\n    solcMetadata = metadata.decoded.solc;\n  } catch {\n    // The decoding failed. Unfortunately, our only option is to assume that this bytecode was emitted by an old version.\n    // Technically, this bytecode could have been emitted by a compiler for another language altogether.\n    // TODO: add detection logic for other compilers if they become relevant?\n    log(\"Could not decode metadata.\");\n    return {\n      metadataSectionSizeInBytes: 0,\n      solcVersion: METADATA_ABSENT_VERSION_RANGE,\n    };\n  }\n\n  if (solcMetadata instanceof Buffer) {\n    if (solcMetadata.length === 3) {\n      const [major, minor, patch] = solcMetadata;\n      const solcVersion = `${major}.${minor}.${patch}`;\n      log(`Solc version detected in bytecode: ${solcVersion}`);\n      return { metadataSectionSizeInBytes, solcVersion };\n    }\n    log(\n      `Found solc version field with ${solcMetadata.length} elements instead of three!`\n    );\n  }\n\n  // The embedded metadata was successfully decoded but there was no solc version in it.\n  log(`Could not detect solidity version in metadata.`);\n  return {\n    metadataSectionSizeInBytes,\n    solcVersion: METADATA_PRESENT_SOLC_NOT_FOUND_VERSION_RANGE,\n  };\n}\n\nexport function decodeSolcMetadata(bytecode: Buffer) {\n  const metadataSectionLength = getSolcMetadataSectionLength(bytecode);\n  // The metadata and its length are in the last few bytes.\n  const metadataPayload = bytecode.slice(\n    -metadataSectionLength,\n    -METADATA_LENGTH_SIZE\n  );\n\n  log(`Read metadata length ${metadataSectionLength}`);\n\n  const lastMetadataBytes = metadataPayload.slice(-100);\n  log(\n    `Last ${\n      lastMetadataBytes.length\n    } bytes of metadata: ${lastMetadataBytes.toString(\"hex\")}`\n  );\n  const decoded = decodeFirstSync(metadataPayload, { required: true });\n  return {\n    decoded,\n    metadataSectionSizeInBytes: metadataSectionLength,\n  };\n}\n\nexport function getSolcMetadataSectionLength(bytecode: Buffer) {\n  return (\n    bytecode.slice(-METADATA_LENGTH_SIZE).readUInt16BE(0) + METADATA_LENGTH_SIZE\n  );\n}\n\n/**\n * This function helps us measure the size of the executable section\n * without actually decoding the whole bytecode string.\n *\n * This is useful because the runtime object emitted by the compiler\n * may contain nonhexadecimal characters due to link placeholders.\n */\nexport function measureExecutableSectionLength(bytecode: string): number {\n  if (bytecode.startsWith(\"0x\")) {\n    bytecode = bytecode.slice(2);\n  }\n\n  // `Buffer.from` will return a buffer that contains bytes up until the last decodable byte.\n  // To work around this we'll just slice the relevant part of the bytecode.\n  const metadataLengthSlice = Buffer.from(\n    bytecode.slice(-METADATA_LENGTH_SIZE * 2),\n    \"hex\"\n  );\n\n  // If, for whatever reason, the bytecode is so small that we can't even read two bytes off it,\n  // return the size of the entire bytecode.\n  if (metadataLengthSlice.length !== METADATA_LENGTH_SIZE) {\n    return bytecode.length;\n  }\n\n  const runtimeMetadataSectionLength =\n    getSolcMetadataSectionLength(metadataLengthSlice);\n\n  return bytecode.length - runtimeMetadataSectionLength * 2;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}