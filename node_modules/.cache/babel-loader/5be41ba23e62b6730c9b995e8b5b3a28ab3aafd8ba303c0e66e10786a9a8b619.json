{"ast":null,"code":"\"use strict\";\n\nimport { Base58 } from \"@quais/basex\";\nimport { arrayify, concat, hexDataSlice, hexZeroPad, hexlify } from \"@quais/bytes\";\nimport { BigNumber } from \"@quais/bignumber\";\nimport { toUtf8Bytes, UnicodeNormalizationForm } from \"@quais/strings\";\nimport { pbkdf2 } from \"@quais/pbkdf2\";\nimport { defineReadOnly } from \"@quais/properties\";\nimport { SigningKey } from \"@quais/signing-key\";\nimport { computeHmac, ripemd160, sha256, SupportedAlgorithm } from \"@quais/sha2\";\nimport { computeAddress } from \"@quais/transactions\";\nimport { wordlists } from \"@quais/wordlists\";\nimport { getShardFromAddress } from \"@quais/address\";\nimport { ShardData } from \"@quais/constants\";\nimport { Logger } from \"@quais/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nconst N = BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n// \"Bitcoin seed\"\nconst MasterSecret = toUtf8Bytes(\"Bitcoin seed\");\nconst HardenedBit = 0x80000000;\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits) {\n  return (1 << bits) - 1 << 8 - bits;\n}\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits) {\n  return (1 << bits) - 1;\n}\nfunction bytes32(value) {\n  return hexZeroPad(hexlify(value), 32);\n}\nfunction base58check(data) {\n  return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));\n}\nfunction getWordlist(wordlist) {\n  if (wordlist == null) {\n    return wordlists[\"en\"];\n  }\n  if (typeof wordlist === \"string\") {\n    const words = wordlists[wordlist];\n    if (words == null) {\n      logger.throwArgumentError(\"unknown locale\", \"wordlist\", wordlist);\n    }\n    return words;\n  }\n  return wordlist;\n}\nconst _constructorGuard = {};\nexport const defaultPath = \"m/44'/994'/0'/0/0\";\nexport const defaultAccountPath = \"m/44'/994'/0'/0/\";\n;\nexport class HDNode {\n  /**\n   *  This constructor should not be called directly.\n   *\n   *  Please use:\n   *   - fromMnemonic\n   *   - fromSeed\n   */\n  constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {\n    /* istanbul ignore if */\n    if (constructorGuard !== _constructorGuard) {\n      throw new Error(\"HDNode constructor cannot be called directly\");\n    }\n    if (privateKey) {\n      const signingKey = new SigningKey(privateKey);\n      defineReadOnly(this, \"privateKey\", signingKey.privateKey);\n      defineReadOnly(this, \"publicKey\", signingKey.compressedPublicKey);\n    } else {\n      defineReadOnly(this, \"privateKey\", null);\n      defineReadOnly(this, \"publicKey\", hexlify(publicKey));\n    }\n    defineReadOnly(this, \"parentFingerprint\", parentFingerprint);\n    defineReadOnly(this, \"fingerprint\", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));\n    defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n    defineReadOnly(this, \"chainCode\", chainCode);\n    defineReadOnly(this, \"index\", index);\n    defineReadOnly(this, \"depth\", depth);\n    if (mnemonicOrPath == null) {\n      // From a source that does not preserve the path (e.g. extended keys)\n      defineReadOnly(this, \"mnemonic\", null);\n      defineReadOnly(this, \"path\", null);\n    } else if (typeof mnemonicOrPath === \"string\") {\n      // From a source that does not preserve the mnemonic (e.g. neutered)\n      defineReadOnly(this, \"mnemonic\", null);\n      defineReadOnly(this, \"path\", mnemonicOrPath);\n    } else {\n      // From a fully qualified source\n      defineReadOnly(this, \"mnemonic\", mnemonicOrPath);\n      defineReadOnly(this, \"path\", mnemonicOrPath.path);\n    }\n  }\n  get extendedKey() {\n    // We only support the mainnet values for now, but if anyone needs\n    // testnet values, let me know. I believe current sentiment is that\n    // we should always use mainnet, and use BIP-44 to derive the network\n    //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n    //   - Testnet: public=0x043587CF, private=0x04358394\n    if (this.depth >= 256) {\n      throw new Error(\"Depth too large!\");\n    }\n    return base58check(concat([this.privateKey != null ? \"0x0488ADE4\" : \"0x0488B21E\", hexlify(this.depth), this.parentFingerprint, hexZeroPad(hexlify(this.index), 4), this.chainCode, this.privateKey != null ? concat([\"0x00\", this.privateKey]) : this.publicKey]));\n  }\n  neuter() {\n    return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\n  }\n  _derive(index) {\n    if (index > 0xffffffff) {\n      throw new Error(\"invalid index - \" + String(index));\n    }\n    // Base path\n    let path = this.path;\n    if (path) {\n      path += \"/\" + (index & ~HardenedBit);\n    }\n    const data = new Uint8Array(37);\n    if (index & HardenedBit) {\n      if (!this.privateKey) {\n        throw new Error(\"cannot derive child of neutered node\");\n      }\n      // Data = 0x00 || ser_256(k_par)\n      data.set(arrayify(this.privateKey), 1);\n      // Hardened path\n      if (path) {\n        path += \"'\";\n      }\n    } else {\n      // Data = ser_p(point(k_par))\n      data.set(arrayify(this.publicKey));\n    }\n    // Data += ser_32(i)\n    for (let i = 24; i >= 0; i -= 8) {\n      data[33 + (i >> 3)] = index >> 24 - i & 0xff;\n    }\n    const I = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    // The private key\n    let ki = null;\n    // The public key\n    let Ki = null;\n    if (this.privateKey) {\n      ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));\n    } else {\n      const ek = new SigningKey(hexlify(IL));\n      Ki = ek._addPoint(this.publicKey);\n    }\n    let mnemonicOrPath = path;\n    const srcMnemonic = this.mnemonic;\n    if (srcMnemonic) {\n      mnemonicOrPath = Object.freeze({\n        phrase: srcMnemonic.phrase,\n        path: path,\n        locale: srcMnemonic.locale || \"en\"\n      });\n    }\n    return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\n  }\n  derivePath(path) {\n    const components = path.split(\"/\");\n    if (components.length === 0 || components[0] === \"m\" && this.depth !== 0) {\n      throw new Error(\"invalid path - \" + path);\n    }\n    if (components[0] === \"m\") {\n      components.shift();\n    }\n    let result = this;\n    for (let i = 0; i < components.length; i++) {\n      const component = components[i];\n      if (component.match(/^[0-9]+'$/)) {\n        const index = parseInt(component.substring(0, component.length - 1));\n        if (index >= HardenedBit) {\n          throw new Error(\"invalid path index - \" + component);\n        }\n        result = result._derive(HardenedBit + index);\n      } else if (component.match(/^[0-9]+$/)) {\n        const index = parseInt(component);\n        if (index >= HardenedBit) {\n          throw new Error(\"invalid path index - \" + component);\n        }\n        result = result._derive(index);\n      } else {\n        throw new Error(\"invalid path component - \" + component);\n      }\n    }\n    return result;\n  }\n  static _fromSeed(seed, mnemonic) {\n    const seedArray = arrayify(seed);\n    if (seedArray.length < 16 || seedArray.length > 64) {\n      throw new Error(\"invalid seed\");\n    }\n    const I = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));\n    return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic);\n  }\n  static fromMnemonic(mnemonic, password, wordlist) {\n    // If a locale name was passed in, find the associated wordlist\n    wordlist = getWordlist(wordlist);\n    // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\n    mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\n    return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\n      phrase: mnemonic,\n      path: \"m\",\n      locale: wordlist.locale\n    });\n  }\n  static fromSeed(seed) {\n    return HDNode._fromSeed(seed, null);\n  }\n  static fromExtendedKey(extendedKey) {\n    const bytes = Base58.decode(extendedKey);\n    if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n      logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n    }\n    const depth = bytes[4];\n    const parentFingerprint = hexlify(bytes.slice(5, 9));\n    const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\n    const chainCode = hexlify(bytes.slice(13, 45));\n    const key = bytes.slice(45, 78);\n    switch (hexlify(bytes.slice(0, 4))) {\n      // Public Key\n      case \"0x0488b21e\":\n      case \"0x043587cf\":\n        return new HDNode(_constructorGuard, null, hexlify(key), parentFingerprint, chainCode, index, depth, null);\n      // Private Key\n      case \"0x0488ade4\":\n      case \"0x04358394 \":\n        if (key[0] !== 0) {\n          break;\n        }\n        return new HDNode(_constructorGuard, hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\n    }\n    return logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n  }\n}\nexport function mnemonicToSeed(mnemonic, password) {\n  if (!password) {\n    password = \"\";\n  }\n  const salt = toUtf8Bytes(\"mnemonic\" + password, UnicodeNormalizationForm.NFKD);\n  return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, \"sha512\");\n}\nexport function mnemonicToEntropy(mnemonic, wordlist) {\n  wordlist = getWordlist(wordlist);\n  logger.checkNormalize();\n  const words = wordlist.split(mnemonic);\n  if (words.length % 3 !== 0) {\n    throw new Error(\"invalid mnemonic\");\n  }\n  const entropy = arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\n  let offset = 0;\n  for (let i = 0; i < words.length; i++) {\n    let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n    if (index === -1) {\n      throw new Error(\"invalid mnemonic\");\n    }\n    for (let bit = 0; bit < 11; bit++) {\n      if (index & 1 << 10 - bit) {\n        entropy[offset >> 3] |= 1 << 7 - offset % 8;\n      }\n      offset++;\n    }\n  }\n  const entropyBits = 32 * words.length / 3;\n  const checksumBits = words.length / 3;\n  const checksumMask = getUpperMask(checksumBits);\n  const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n    throw new Error(\"invalid checksum\");\n  }\n  return hexlify(entropy.slice(0, entropyBits / 8));\n}\nexport function entropyToMnemonic(entropy, wordlist) {\n  wordlist = getWordlist(wordlist);\n  entropy = arrayify(entropy);\n  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {\n    throw new Error(\"invalid entropy\");\n  }\n  const indices = [0];\n  let remainingBits = 11;\n  for (let i = 0; i < entropy.length; i++) {\n    // Consume the whole byte (with still more to go)\n    if (remainingBits > 8) {\n      indices[indices.length - 1] <<= 8;\n      indices[indices.length - 1] |= entropy[i];\n      remainingBits -= 8;\n      // This byte will complete an 11-bit index\n    } else {\n      indices[indices.length - 1] <<= remainingBits;\n      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;\n      // Start the next word\n      indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n      remainingBits += 3;\n    }\n  }\n  // Compute the checksum bits\n  const checksumBits = entropy.length / 4;\n  const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);\n  // Shift the checksum into the word indices\n  indices[indices.length - 1] <<= checksumBits;\n  indices[indices.length - 1] |= checksum >> 8 - checksumBits;\n  return wordlist.join(indices.map(index => wordlist.getWord(index)));\n}\nexport function isValidMnemonic(mnemonic, wordlist) {\n  try {\n    mnemonicToEntropy(mnemonic, wordlist);\n    return true;\n  } catch (error) {}\n  return false;\n}\nexport function getAccountPath(index) {\n  if (typeof index !== \"number\" || index < 0 || index >= HardenedBit || index % 1) {\n    logger.throwArgumentError(\"invalid account index\", \"index\", index);\n  }\n  return `m/44'/60'/${index}'/0/0`;\n}\nexport function getShardAddressChildNode(hdnode, path, startingIndex, shard) {\n  let found = false;\n  let childNode;\n  while (!found) {\n    childNode = hdnode.derivePath(path + \"/\" + startingIndex.toString());\n    const addrShard = getShardFromAddress(childNode.address);\n    // Check if address is in a shard\n    if (addrShard !== undefined) {\n      // Check if address is in correct shard\n      if (addrShard === shard) {\n        found = true;\n        break;\n      }\n    }\n    startingIndex++;\n  }\n  return childNode;\n}\nexport function getAllShardsAddressChildNode(hdnode, accountPath) {\n  const childNodes = [];\n  let shards = ShardData.map(shard => shard.shard);\n  for (const shard of shards) {\n    const childNode = getShardAddressChildNode(hdnode, accountPath, 0, shard);\n    childNodes.push(childNode);\n  }\n  return childNodes;\n}","map":{"version":3,"names":["Base58","arrayify","concat","hexDataSlice","hexZeroPad","hexlify","BigNumber","toUtf8Bytes","UnicodeNormalizationForm","pbkdf2","defineReadOnly","SigningKey","computeHmac","ripemd160","sha256","SupportedAlgorithm","computeAddress","wordlists","getShardFromAddress","ShardData","Logger","version","logger","N","from","MasterSecret","HardenedBit","getUpperMask","bits","getLowerMask","bytes32","value","base58check","data","encode","getWordlist","wordlist","words","throwArgumentError","_constructorGuard","defaultPath","defaultAccountPath","HDNode","constructor","constructorGuard","privateKey","publicKey","parentFingerprint","chainCode","index","depth","mnemonicOrPath","Error","signingKey","compressedPublicKey","path","extendedKey","neuter","_derive","String","Uint8Array","set","i","I","sha512","IL","slice","IR","ki","Ki","add","mod","ek","_addPoint","srcMnemonic","mnemonic","Object","freeze","phrase","locale","fingerprint","derivePath","components","split","length","shift","result","component","match","parseInt","substring","_fromSeed","seed","seedArray","fromMnemonic","password","entropyToMnemonic","mnemonicToEntropy","mnemonicToSeed","fromSeed","fromExtendedKey","bytes","decode","key","salt","NFKD","checkNormalize","entropy","Math","ceil","offset","getWordIndex","normalize","bit","entropyBits","checksumBits","checksumMask","checksum","indices","remainingBits","push","join","map","getWord","isValidMnemonic","error","getAccountPath","getShardAddressChildNode","hdnode","startingIndex","shard","found","childNode","toString","addrShard","address","undefined","getAllShardsAddressChildNode","accountPath","childNodes","shards"],"sources":["/workspace/quanion/node_modules/@quais/hdnode/src.ts/index.ts"],"sourcesContent":["\"use strict\";\n\n// See: https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n\n\nimport { ExternallyOwnedAccount } from \"@quais/abstract-signer\";\nimport { Base58 } from \"@quais/basex\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexZeroPad, hexlify } from \"@quais/bytes\";\nimport { BigNumber } from \"@quais/bignumber\";\nimport { toUtf8Bytes, UnicodeNormalizationForm } from \"@quais/strings\";\nimport { pbkdf2 } from \"@quais/pbkdf2\";\nimport { defineReadOnly } from \"@quais/properties\";\nimport { SigningKey } from \"@quais/signing-key\";\nimport { computeHmac, ripemd160, sha256, SupportedAlgorithm } from \"@quais/sha2\";\nimport { computeAddress } from \"@quais/transactions\";\nimport { Wordlist, wordlists } from \"@quais/wordlists\";\nimport { getShardFromAddress } from \"@quais/address\";\nimport { ShardData } from \"@quais/constants\";\n\nimport { Logger } from \"@quais/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst N = BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n\n\n// \"Bitcoin seed\"\nconst MasterSecret = toUtf8Bytes(\"Bitcoin seed\");\n\nconst HardenedBit = 0x80000000;\n\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits: number): number {\n   return ((1 << bits) - 1) << (8 - bits);\n}\n\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits: number): number {\n   return (1 << bits) - 1;\n}\n\nfunction bytes32(value: BigNumber | Uint8Array): string {\n    return hexZeroPad(hexlify(value), 32);\n}\n\nfunction base58check(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nfunction getWordlist(wordlist: string | Wordlist): Wordlist {\n    if (wordlist == null) {\n        return wordlists[\"en\"];\n    }\n\n    if (typeof(wordlist) === \"string\") {\n        const words = wordlists[wordlist];\n        if (words == null) {\n            logger.throwArgumentError(\"unknown locale\", \"wordlist\", wordlist);\n        }\n        return words;\n    }\n\n    return wordlist;\n}\n\nconst _constructorGuard: any = {};\n\nexport const defaultPath = \"m/44'/994'/0'/0/0\";\nexport const defaultAccountPath = \"m/44'/994'/0'/0/\";\n\nexport interface Mnemonic {\n    readonly phrase: string;\n    readonly path: string;\n    readonly locale: string;\n};\n\nexport class HDNode implements ExternallyOwnedAccount {\n    readonly privateKey: string;\n    readonly publicKey: string;\n\n    readonly fingerprint: string;\n    readonly parentFingerprint: string;\n\n    readonly address: string;\n\n    readonly mnemonic?: Mnemonic;\n    readonly path: string;\n\n    readonly chainCode: string;\n\n    readonly index: number;\n    readonly depth: number;\n\n    /**\n     *  This constructor should not be called directly.\n     *\n     *  Please use:\n     *   - fromMnemonic\n     *   - fromSeed\n     */\n    constructor(constructorGuard: any, privateKey: string, publicKey: string, parentFingerprint: string, chainCode: string, index: number, depth: number, mnemonicOrPath: Mnemonic | string) {\n        /* istanbul ignore if */\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"HDNode constructor cannot be called directly\");\n        }\n\n        if (privateKey) {\n            const signingKey = new SigningKey(privateKey);\n            defineReadOnly(this, \"privateKey\", signingKey.privateKey);\n            defineReadOnly(this, \"publicKey\", signingKey.compressedPublicKey);\n        } else {\n            defineReadOnly(this, \"privateKey\", null);\n            defineReadOnly(this, \"publicKey\", hexlify(publicKey));\n        }\n\n        defineReadOnly(this, \"parentFingerprint\", parentFingerprint);\n        defineReadOnly(this, \"fingerprint\", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));\n\n        defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n\n        defineReadOnly(this, \"chainCode\", chainCode);\n\n        defineReadOnly(this, \"index\", index);\n        defineReadOnly(this, \"depth\", depth);\n\n        if (mnemonicOrPath == null) {\n            // From a source that does not preserve the path (e.g. extended keys)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", null);\n\n        } else if (typeof(mnemonicOrPath) === \"string\") {\n            // From a source that does not preserve the mnemonic (e.g. neutered)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", mnemonicOrPath);\n\n        } else {\n            // From a fully qualified source\n            defineReadOnly(this, \"mnemonic\", mnemonicOrPath);\n            defineReadOnly(this, \"path\", mnemonicOrPath.path);\n        }\n    }\n\n    get extendedKey(): string {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n\n        if (this.depth >= 256) { throw new Error(\"Depth too large!\"); }\n\n        return base58check(concat([\n            ((this.privateKey != null) ? \"0x0488ADE4\": \"0x0488B21E\"),\n            hexlify(this.depth),\n            this.parentFingerprint,\n            hexZeroPad(hexlify(this.index), 4),\n            this.chainCode,\n            ((this.privateKey != null) ? concat([ \"0x00\", this.privateKey ]): this.publicKey),\n        ]));\n    }\n\n    neuter(): HDNode {\n        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\n    }\n\n    private _derive(index: number): HDNode {\n        if (index > 0xffffffff) { throw new Error(\"invalid index - \" + String(index)); }\n\n        // Base path\n        let path = this.path;\n        if (path) { path += \"/\" + (index & ~HardenedBit); }\n\n        const data = new Uint8Array(37);\n\n        if (index & HardenedBit) {\n            if (!this.privateKey) {\n                throw new Error(\"cannot derive child of neutered node\");\n            }\n\n            // Data = 0x00 || ser_256(k_par)\n            data.set(arrayify(this.privateKey), 1);\n\n            // Hardened path\n            if (path) { path += \"'\"; }\n\n        } else {\n            // Data = ser_p(point(k_par))\n            data.set(arrayify(this.publicKey));\n        }\n\n        // Data += ser_32(i)\n        for (let i = 24; i >= 0; i -= 8) { data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff); }\n\n        const I = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n\n        // The private key\n        let ki: string = null\n\n        // The public key\n        let Ki: string = null;\n\n        if (this.privateKey) {\n            ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));\n        } else {\n            const ek = new SigningKey(hexlify(IL));\n            Ki = ek._addPoint(this.publicKey);\n        }\n\n        let mnemonicOrPath: Mnemonic | string = path;\n\n        const srcMnemonic =  this.mnemonic;\n        if (srcMnemonic) {\n            mnemonicOrPath = Object.freeze({\n                phrase: srcMnemonic.phrase,\n                path: path,\n                locale: (srcMnemonic.locale || \"en\")\n            });\n        }\n\n        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\n    }\n\n    derivePath(path: string): HDNode {\n        const components = path.split(\"/\");\n\n        if (components.length === 0 || (components[0] === \"m\" && this.depth !== 0)) {\n            throw new Error(\"invalid path - \" + path);\n        }\n\n        if (components[0] === \"m\") { components.shift(); }\n\n        let result: HDNode = this;\n        for (let i = 0; i < components.length; i++) {\n            const component = components[i];\n            if (component.match(/^[0-9]+'$/)) {\n                const index = parseInt(component.substring(0, component.length - 1));\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(HardenedBit + index);\n            } else if (component.match(/^[0-9]+$/)) {\n                const index = parseInt(component);\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(index);\n            } else {\n                throw new Error(\"invalid path component - \" + component);\n            }\n        }\n\n        return result;\n    }\n\n\n    static _fromSeed(seed: BytesLike, mnemonic: Mnemonic): HDNode {\n        const seedArray: Uint8Array = arrayify(seed);\n        if (seedArray.length < 16 || seedArray.length > 64) { throw new Error(\"invalid seed\"); }\n\n        const I: Uint8Array = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));\n\n        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic);\n    }\n\n    static fromMnemonic(mnemonic: string, password?: string, wordlist?: string | Wordlist): HDNode {\n\n        // If a locale name was passed in, find the associated wordlist\n        wordlist = getWordlist(wordlist);\n\n        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\n        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\n\n        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\n            phrase: mnemonic,\n            path: \"m\",\n            locale: wordlist.locale\n        });\n    }\n\n    static fromSeed(seed: BytesLike): HDNode {\n        return HDNode._fromSeed(seed, null);\n    }\n\n    static fromExtendedKey(extendedKey: string): HDNode {\n        const bytes = Base58.decode(extendedKey);\n\n        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n            logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n        }\n\n        const depth = bytes[4];\n        const parentFingerprint = hexlify(bytes.slice(5, 9));\n        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\n        const chainCode = hexlify(bytes.slice(13, 45));\n        const key = bytes.slice(45, 78);\n\n        switch (hexlify(bytes.slice(0, 4))) {\n            // Public Key\n            case \"0x0488b21e\": case \"0x043587cf\":\n                return new HDNode(_constructorGuard, null, hexlify(key), parentFingerprint, chainCode, index, depth, null);\n\n            // Private Key\n            case \"0x0488ade4\": case \"0x04358394 \":\n                if (key[0] !== 0) { break; }\n                return new HDNode(_constructorGuard, hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\n        }\n\n        return logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n    }\n}\n\nexport function mnemonicToSeed(mnemonic: string, password?: string): string {\n    if (!password) { password = \"\"; }\n\n    const salt = toUtf8Bytes(\"mnemonic\" + password, UnicodeNormalizationForm.NFKD);\n\n    return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, \"sha512\");\n}\n\nexport function mnemonicToEntropy(mnemonic: string, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    logger.checkNormalize();\n\n    const words = wordlist.split(mnemonic);\n    if ((words.length % 3) !== 0) { throw new Error(\"invalid mnemonic\"); }\n\n    const entropy = arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\n\n    let offset = 0;\n    for (let i = 0; i < words.length; i++) {\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        if (index === -1) { throw new Error(\"invalid mnemonic\"); }\n\n        for (let bit = 0; bit < 11; bit++) {\n            if (index & (1 << (10 - bit))) {\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n            }\n            offset++;\n        }\n    }\n\n    const entropyBits = 32 * words.length / 3;\n\n    const checksumBits = words.length / 3;\n    const checksumMask = getUpperMask(checksumBits);\n\n    const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\n    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n        throw new Error(\"invalid checksum\");\n    }\n\n    return hexlify(entropy.slice(0, entropyBits / 8));\n}\n\nexport function entropyToMnemonic(entropy: BytesLike, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    entropy = arrayify(entropy);\n\n    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {\n        throw new Error(\"invalid entropy\");\n    }\n\n    const indices: Array<number> = [ 0 ];\n\n    let remainingBits = 11;\n    for (let i = 0; i < entropy.length; i++) {\n\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n\n            remainingBits -= 8;\n\n        // This byte will complete an 11-bit index\n        } else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n\n            remainingBits += 3;\n        }\n    }\n\n    // Compute the checksum bits\n    const checksumBits = entropy.length / 4;\n    const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);\n\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n\n    return wordlist.join(indices.map((index) => (<Wordlist>wordlist).getWord(index)));\n}\n\nexport function isValidMnemonic(mnemonic: string, wordlist?: Wordlist): boolean {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getAccountPath(index: number): string {\n    if (typeof(index) !== \"number\" || index < 0 || index >= HardenedBit || index % 1) {\n        logger.throwArgumentError(\"invalid account index\", \"index\", index);\n    }\n    return `m/44'/60'/${ index }'/0/0`;\n}\n\n\nexport function getShardAddressChildNode(hdnode: HDNode, path: string, startingIndex: number, shard: string) {\n    let found = false;\n    let childNode;\n    while (!found) {\n        childNode = hdnode.derivePath(path + \"/\" + startingIndex.toString());\n        const addrShard = getShardFromAddress(childNode.address);\n        // Check if address is in a shard\n        if (addrShard !== undefined) {\n            // Check if address is in correct shard\n            if (addrShard === shard) {\n                found = true;\n                break;\n            }\n        }\n        startingIndex++;\n    }\n    return childNode;\n}\n  \nexport function getAllShardsAddressChildNode(hdnode: HDNode, accountPath: string) {\n    const childNodes = [];\n    let shards = ShardData.map((shard) => shard.shard);\n\n    for (const shard of shards) {\n        const childNode = getShardAddressChildNode(hdnode, accountPath, 0, shard);\n        childNodes.push(childNode);\n    }\n\n    return childNodes;\n}\n  \n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}